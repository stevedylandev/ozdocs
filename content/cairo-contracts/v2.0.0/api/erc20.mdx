---
title: ERC20
description: ERC20
---

This module provides interfaces, presets, and utilities related to ERC20 contracts.

<Callout>
For an overview of ERC20, read our [ERC20 guide](erc20.adoc).
</Callout>

## Interfaces

<Callout>
Starting from version `3.x.x`, the interfaces are no longer part of the `openzeppelin_token` package. The references
</Callout>
documented here are contained in the `openzeppelin_interfaces` package version `current_openzeppelin_interfaces_version`.

### `++IERC20++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc20.cairo[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

```rust
use openzeppelin_interfaces::erc20::IERC20;
```

Interface of the IERC20 standard as defined in [EIP-20](https://eips.ethereum.org/EIPS/eip-20).

**Functions**

* [`+total_supply()+`](#`[.contract-item-name]#++total_supply++#++()-‚Üí-u256++`-[.item-kind]#external#)
* [`+balance_of(account)+`](#`[.contract-item-name]#++balance_of++#++(account:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+allowance(owner, spender)+`](#`[.contract-item-name]#++allowance++#++(owner:-contractaddress,-spender:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+transfer(recipient, amount)+`](#`[.contract-item-name]#++transfer++#++(recipient:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#)
* [`+transfer_from(sender, recipient, amount)+`](#`[.contract-item-name]#++transfer_from++#++(sender:-contractaddress,-recipient:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#)
* [`+approve(spender, amount)+`](#`[.contract-item-name]#++approve++#++(spender:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#)

**Events**

* [`+Transfer(from, to, value)+`](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-value:-u256)++`-[.item-kind]#event#)
* [`+Approval(owner, spender, value)+`](#`[.contract-item-name]#++approval++#++(owner:-contractaddress,-spender:-contractaddress,-value:-u256)++`-[.item-kind]#event#)

#### Functions

#### `[.contract-item-name]#++total_supply++#++() ‚Üí u256++` [.item-kind]#external#

Returns the amount of tokens in existence.

#### `[.contract-item-name]#++balance_of++#++(account: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Returns the amount of tokens owned by `account`.

#### `[.contract-item-name]#++allowance++#++(owner: ContractAddress, spender: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Returns the remaining number of tokens that `spender` is allowed to spend on behalf of `owner` through [transfer_from](#transfer_from). This is zero by default.

This value changes when [approve](#`[.contract-item-name]#++approve++#++(spender:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#) or [transfer_from](#`[.contract-item-name]#++transfer_from++#++(sender:-contractaddress,-recipient:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#) are called.

#### `[.contract-item-name]#++transfer++#++(recipient: ContractAddress, amount: u256) ‚Üí bool++` [.item-kind]#external#

Moves `amount` tokens from the caller‚Äôs token balance to `to`.
Returns `true` on success, reverts otherwise.

Emits a [Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-value:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++transfer_from++#++(sender: ContractAddress, recipient: ContractAddress, amount: u256) ‚Üí bool++` [.item-kind]#external#

Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.
`amount` is then deducted from the caller‚Äôs allowance.
Returns `true` on success, reverts otherwise.

Emits a [Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-value:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++approve++#++(spender: ContractAddress, amount: u256) ‚Üí bool++` [.item-kind]#external#

Sets `amount` as the allowance of `spender` over the caller‚Äôs tokens.
Returns `true` on success, reverts otherwise.

Emits an [Approval](#ERC20-Approval) event.

#### Events

#### `[.contract-item-name]#++Transfer++#++(from: ContractAddress, to: ContractAddress, value: u256)++` [.item-kind]#event#

Emitted when `value` tokens are moved from one address (`from`) to another (`to`).

Note that `value` may be zero.

#### `[.contract-item-name]#++Approval++#++(owner: ContractAddress, spender: ContractAddress, value: u256)++` [.item-kind]#event#

Emitted when the allowance of a `spender` for an `owner` is set.
`value` is the new allowance.

### `++IERC20Metadata++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc20.cairo[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

```rust
use openzeppelin_interfaces::erc20::IERC20Metadata;
```

Interface for the optional metadata functions in [EIP-20](https://eips.ethereum.org/EIPS/eip-20).

**Functions**

* [`+name()+`](#`[.contract-item-name]#++name++#++()-‚Üí-bytearray++`-[.item-kind]#external#)
* [`+symbol()+`](#`[.contract-item-name]#++symbol++#++()-‚Üí-bytearray++`-[.item-kind]#external#)
* [`+decimals()+`](#`[.contract-item-name]#++decimals++#++()-‚Üí-u8++`-[.item-kind]#external#)

#### Functions

#### `[.contract-item-name]#++name++#++() ‚Üí ByteArray++` [.item-kind]#external#

Returns the name of the token.

#### `[.contract-item-name]#++symbol++#++() ‚Üí ByteArray++` [.item-kind]#external#

Returns the ticker symbol of the token.

#### `[.contract-item-name]#++decimals++#++() ‚Üí u8++` [.item-kind]#external#

Returns the number of decimals the token uses - e.g. `8` means to divide the token amount by `100000000` to get its user-readable representation.

For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`).

Tokens usually opt for a value of `18`, imitating the relationship between Ether and Wei.
This is the default value returned by this function.
To create a custom decimals implementation, see [Customizing decimals](/erc20.adoc#customizing_decimals).

<Callout>
This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract.
</Callout>

### `++IERC20Permit++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc20.cairo[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

```rust
use openzeppelin_interfaces::erc20::IERC20Permit;
```

Interface of the ERC20Permit standard to support gasless token approvals as defined in [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612).

**Functions**

* [`+permit(owner, spender, amount, deadline, signature)+`](#`[.contract-item-name]#++permit++#++(owner:-contractaddress,-spender:-contractaddress,-amount:-u256,-deadline:-u64,-signature:-span<felt252>)++`-[.item-kind]#external#)
* [`+nonces(owner)+`](#`[.contract-item-name]#++nonces++#++(owner:-contractaddress)-‚Üí-felt252++`-[.item-kind]#external#)
* [`+DOMAIN_SEPARATOR()+`](#`[.contract-item-name]#++domain_separator++#++()-‚Üí-felt252++`-[.item-kind]#external#)

#### Functions

#### `[.contract-item-name]#++permit++#++(owner: ContractAddress, spender: ContractAddress, amount: u256, deadline: u64, signature: Span<felt252>)++` [.item-kind]#external#

Sets `amount` as the allowance of `spender` over ``owner`‚Äôs tokens after validating the signature.

#### `[.contract-item-name]#++nonces++#++(owner: ContractAddress) ‚Üí felt252++` [.item-kind]#external#

Returns the current nonce of `owner`. A nonce value must be included
whenever a signature for `permit` call is generated.

#### `[.contract-item-name]#++DOMAIN_SEPARATOR++#++() ‚Üí felt252++` [.item-kind]#external#

Returns the domain separator used in generating a message hash for `permit` signature.
The domain hashing logic follows the [SNIP12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) standard.

### `++IERC4626++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc4626.cairo[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

```rust
use openzeppelin_interfaces::erc4626::IERC4626;
```

Interface of the IERC4626 standard as defined in [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626).

**Functions**

* [`+asset()+`](#`[.contract-item-name]#++asset++#++()-‚Üí-contractaddress++`-[.item-kind]#external#)
* [`+total_assets()+`](#`[.contract-item-name]#++total_assets++#++()-‚Üí-u256++`-[.item-kind]#external#)
* [`+convert_to_shares(assets)+`](#`[.contract-item-name]#++convert_to_shares++#++(assets:-u256)-‚Üí-u256++`-[.item-kind]#external#)
* [`+convert_to_assets(shares)+`](#`[.contract-item-name]#++convert_to_assets++#++(shares:-u256)-‚Üí-u256++`-[.item-kind]#external#)
* [`+max_deposit(receiver)+`](#`[.contract-item-name]#++max_deposit++#++(receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+preview_deposit(assets)+`](#`[.contract-item-name]#++preview_deposit++#++(assets:-u256)-‚Üí-u256++`-[.item-kind]#external#)
* [`+deposit(assets, receiver)+`](#`[.contract-item-name]#++deposit++#++(assets:-u256,-receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+max_mint(receiver)+`](#`[.contract-item-name]#++max_mint++#++(receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+preview_mint(shares)+`](#`[.contract-item-name]#++preview_mint++#++(shares:-u256)-‚Üí-u256++`-[.item-kind]#external#)
* [`+mint(shares, receiver)+`](#`[.contract-item-name]#++mint++#++(shares:-u256,-receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+max_withdraw(owner)+`](#`[.contract-item-name]#++max_withdraw++#++(owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+preview_withdraw(assets)+`](#`[.contract-item-name]#++preview_withdraw++#++(assets:-u256)-‚Üí-u256++`-[.item-kind]#external#)
* [`+withdraw(assets, receiver, owner)+`](#`[.contract-item-name]#++withdraw++#++(assets:-u256,-receiver:-contractaddress,-owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+max_redeem(owner)+`](#`[.contract-item-name]#++max_redeem++#++(owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+preview_redeem(shares)+`](#`[.contract-item-name]#++preview_redeem++#++(shares:-u256)-‚Üí-u256++`-[.item-kind]#external#)
* [`+redeem(shares, receiver, owner)+`](#`[.contract-item-name]#++redeem++#++(shares:-u256,-receiver:-contractaddress,-owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)

**Events**

* [`+Deposit(sender, owner, assets, shares)+`](#`[.contract-item-name]#++deposit++#++(sender:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#event#)
* [`+Withdraw(sender, receiver, owner, assets, shares)+`](#`[.contract-item-name]#++withdraw++#++(sender:-contractaddress,-receiver:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#event#)

#### Functions

#### `[.contract-item-name]#++asset++#++() ‚Üí ContractAddress++` [.item-kind]#external#

Returns the address of the underlying token used for the Vault for accounting, depositing,
and withdrawing.

Requirements:

* MUST be an ERC20 token contract.
* MUST NOT panic.

#### `[.contract-item-name]#++total_assets++#++() ‚Üí u256++` [.item-kind]#external#

Returns the total amount of the underlying asset that is ‚Äúmanaged‚Äù by Vault.

Requirements:

* SHOULD include any compounding that occurs from yield.
* MUST be inclusive of any fees that are charged against assets in the Vault.
* MUST NOT panic.

#### `[.contract-item-name]#++convert_to_shares++#++(assets: u256) ‚Üí u256++` [.item-kind]#external#

Returns the amount of shares that the Vault would exchange for the amount of `assets`
provided irrespective of slippage or fees.

Requirements:

* MUST NOT be inclusive of any fees that are charged against assets in the Vault.
* MUST NOT show any variations depending on the caller.
* MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.
* MUST NOT panic unless due to integer overflow caused by an unreasonably large input.
* MUST round down towards 0.

<Callout>
This calculation MAY NOT reflect the "per-user" price-per-share, and instead should
</Callout>
reflect the "average-user‚Äôs" price-per-share, meaning what the average user should expect to
see when exchanging to and from.

#### `[.contract-item-name]#++convert_to_assets++#++(shares: u256) ‚Üí u256++` [.item-kind]#external#

Returns the amount of assets that the Vault would exchange for the amount of `shares`
provided irrespective of slippage or fees.

Requirements:

* MUST NOT be inclusive of any fees that are charged against assets in the Vault.
* MUST NOT show any variations depending on the caller.
* MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.
* MUST NOT panic unless due to integer overflow caused by an unreasonably large input.
* MUST round down towards 0.

<Callout>
This calculation MAY NOT reflect the ‚Äúper-user‚Äù price-per-share, and instead
</Callout>
should reflect the ‚Äúaverage-user‚Äôs‚Äù price-per-share, meaning what the average user
should expect to see when exchanging to and from.

#### `[.contract-item-name]#++max_deposit++#++(receiver: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Returns the maximum amount of the underlying asset that can be deposited into the Vault for
`receiver`, through a deposit call.

Requirements:

* MUST return a limited value if receiver is subject to some deposit limit.
* MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be
  deposited.
* MUST NOT panic.

#### `[.contract-item-name]#++preview_deposit++#++(assets: u256) ‚Üí u256++` [.item-kind]#external#

Allows an on-chain or off-chain user to simulate the effects of their deposit at the current
block, given current on-chain conditions.

Requirements:

* MUST return as close to and no more than the exact amount of Vault shares that would be
  minted in a deposit call in the same transaction i.e. [IERC4626::deposit](#`[.contract-item-name]#++deposit++#++(assets:-u256,-receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#) should return the same or more
  shares as `preview_deposit` if called in the same transaction.
* MUST NOT account for deposit limits like those returned from [IERC4626::max_deposit](#`[.contract-item-name]#++max_deposit++#++(receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#) and should always
  act as though the deposit would be accepted, regardless if the user has enough tokens
  approved, etc.
* MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit
  fees.
* MUST NOT panic.

<Callout>
Any unfavorable discrepancy between [IERC4626::convert_to_shares](#`[.contract-item-name]#++convert_to_shares++#++(assets:-u256)-‚Üí-u256++`-[.item-kind]#external#) and `preview_deposit`
</Callout>
SHOULD be considered slippage in share price or some other type of condition, meaning the
depositor will lose assets by depositing.

#### `[.contract-item-name]#++deposit++#++(assets: u256, receiver: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Mints Vault shares to `receiver` by depositing exactly amount of `assets`.

Requirements:

* MUST emit the [IERC4626::Deposit](#`[.contract-item-name]#++deposit++#++(sender:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#event#) event.
* MAY support an additional flow in which the underlying tokens are owned by the Vault
  contract before the deposit execution, and are accounted for during deposit.
* MUST panic if all of assets cannot be deposited (due to deposit limit being reached,
  slippage, the user not approving enough underlying tokens to the Vault contract, etc).

<Callout>
Most implementations will require pre-approval of the Vault with the Vault‚Äôs
</Callout>
underlying asset token.

#### `[.contract-item-name]#++max_mint++#++(receiver: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Returns the maximum amount of the Vault shares that can be minted for the receiver, through
a mint call.

Requirements:

* MUST return a limited value if receiver is subject to some mint limit.
* MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be
  minted.
* MUST NOT panic.

#### `[.contract-item-name]#++preview_mint++#++(shares: u256) ‚Üí u256++` [.item-kind]#external#

Allows an on-chain or off-chain user to simulate the effects of their mint at the current
block, given current on-chain conditions.

Requirements:

* MUST return as close to and no fewer than the exact amount of assets that would be deposited
  in a `mint` call in the same transaction. I.e. [IERC4626::mint](#`[.contract-item-name]#++mint++#++(shares:-u256,-receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#) should return the same or fewer assets
  as `preview_mint` if called in the same transaction.
* MUST NOT account for mint limits like those returned from [IERC4626::max_mint](#`[.contract-item-name]#++max_mint++#++(receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#) and should always act
  as though the mint would be accepted, regardless if the user has enough tokens approved,
  etc.
* MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit
  fees.
* MUST NOT panic.

<Callout>
Any unfavorable discrepancy between [IERC4626::convert_to_assets](#`[.contract-item-name]#++convert_to_assets++#++(shares:-u256)-‚Üí-u256++`-[.item-kind]#external#) and
</Callout>
`preview_mint` SHOULD be considered slippage in share price or some other type of condition,
meaning the depositor will lose assets by minting.

#### `[.contract-item-name]#++mint++#++(shares: u256, receiver: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.

Requirements:

* MUST emit the [IERC4626::Deposit](#`[.contract-item-name]#++deposit++#++(sender:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#event#) event.
* MAY support an additional flow in which the underlying tokens are owned by the Vault
  contract before the mint execution, and are accounted for during mint.
* MUST panic if all of shares cannot be minted (due to deposit limit being reached, slippage,
  the user not approving enough underlying tokens to the Vault contract, etc).

<Callout>
Most implementations will require pre-approval of the Vault with the Vault‚Äôs
</Callout>
underlying asset token.

#### `[.contract-item-name]#++max_withdraw++#++(owner: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Returns the maximum amount of the underlying asset that can be withdrawn from the owner
balance in the Vault, through a withdraw call.

Requirements:

* MUST return a limited value if owner is subject to some withdrawal limit or timelock.
* MUST NOT panic.

#### `[.contract-item-name]#++preview_withdraw++#++(assets: u256) ‚Üí u256++` [.item-kind]#external#

Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the
current block, given current on-chain conditions.

Requirements:

* MUST return as close to and no fewer than the exact amount of Vault shares that would be
  burned in a withdraw call in the same transaction i.e. [IERC4626::withdraw](#`[.contract-item-name]#++withdraw++#++(assets:-u256,-receiver:-contractaddress,-owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#) should return the same or
  fewer shares as `preview_withdraw` if called in the same transaction.
* MUST NOT account for withdrawal limits like those returned from [IERC4626::max_withdraw](#`[.contract-item-name]#++max_withdraw++#++(owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#) and should
  always act as though the withdrawal would be accepted, regardless if the user has enough
  shares, etc.
* MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of
  withdrawal fees.
* MUST NOT panic.

<Callout>
Any unfavorable discrepancy between [IERC4626::convert_to_shares](#`[.contract-item-name]#++convert_to_shares++#++(assets:-u256)-‚Üí-u256++`-[.item-kind]#external#) and `preview_withdraw`
</Callout>
SHOULD be considered slippage in share price or some other type of condition, meaning the
depositor will lose assets by depositing.

#### `[.contract-item-name]#++withdraw++#++(assets: u256, receiver: ContractAddress, owner: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Burns shares from owner and sends exactly assets of underlying tokens to receiver.

Requirements:

* MUST emit the [IERC4626::Withdraw](#`[.contract-item-name]#++withdraw++#++(sender:-contractaddress,-receiver:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#event#) event.
* MAY support an additional flow in which the underlying tokens are owned by the Vault
  contract before the withdraw execution, and are accounted for during withdraw.
* MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached,
  slippage, the owner not having enough shares, etc).

<Callout>
Some implementations will require pre-requesting to the Vault before a withdrawal
</Callout>
may be performed.
Those methods should be performed separately.

#### `[.contract-item-name]#++max_redeem++#++(owner: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Returns the maximum amount of Vault shares that can be redeemed from the owner balance in
the Vault, through a redeem call.

Requirements:

* MUST return a limited value if owner is subject to some withdrawal limit or timelock.
* MUST return `ERC20::balance_of(owner)` if `owner` is not subject to any withdrawal limit or
  timelock.
* MUST NOT panic.

#### `[.contract-item-name]#++preview_redeem++#++(shares: u256) ‚Üí u256++` [.item-kind]#external#

Allows an on-chain or off-chain user to simulate the effects of their redeemption at the
current block, given current on-chain conditions.

Requirements:

* MUST return as close to and no more than the exact amount of assets that would be withdrawn
  in a redeem call in the same transaction i.e. [IERC4626::redeem](#`[.contract-item-name]#++redeem++#++(shares:-u256,-receiver:-contractaddress,-owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#) should return the same or more assets
  as preview_redeem if called in the same transaction.
* MUST NOT account for redemption limits like those returned from [IERC4626::max_redeem](#`[.contract-item-name]#++max_redeem++#++(owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#) and should always
  act as though the redemption would be accepted, regardless if the user has enough shares,
  etc.
* MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of
  withdrawal fees.
* MUST NOT panic.

<Callout>
Any unfavorable discrepancy between [IERC4626::convert_to_assets](#`[.contract-item-name]#++convert_to_assets++#++(shares:-u256)-‚Üí-u256++`-[.item-kind]#external#) and `preview_redeem` SHOULD be
</Callout>
considered slippage in share price or some other type of condition, meaning the depositor
will lose assets by redeeming.

#### `[.contract-item-name]#++redeem++#++(shares: u256, receiver: ContractAddress, owner: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Burns exactly shares from owner and sends assets of underlying tokens to receiver.

Requirements:

* MUST emit the [IERC4626::Withdraw](#`[.contract-item-name]#++withdraw++#++(sender:-contractaddress,-receiver:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#event#) event.
* MAY support an additional flow in which the underlying tokens are owned by the Vault
  contract before the redeem execution, and are accounted for during redeem.
* MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached,
  slippage, the owner not having enough shares, etc).

<Callout>
Some implementations will require pre-requesting to the Vault before a withdrawal may be performed.
</Callout>
Those methods should be performed separately.

#### Events

#### `[.contract-item-name]#++Deposit++#++(sender: ContractAddress, owner: ContractAddress, assets: u256, shares: u256)++` [.item-kind]#event#

Emitted when `sender` exchanges `assets` for `shares` and transfers those
`shares` to `owner`.

#### `[.contract-item-name]#++Withdraw++#++(sender: ContractAddress, receiver: ContractAddress, owner: ContractAddress, assets: u256, shares: u256)++` [.item-kind]#event#

Emitted when `sender` exchanges `shares`, owned by `owner`, for `assets` and transfers
those `assets` to `receiver`.

## Core

### `++ERC20Component++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/token/src/erc20/erc20.cairo[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

```rust
use openzeppelin_token::erc20::ERC20Component;
```
ERC20 component extending [IERC20](#`++ierc20++`-link:https://github.com/openzeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc20.cairo[pass:[<svg-class="icon"><use-href="#github-icon"/></svg>],role=heading-link]) and [IERC20Metadata](#`++ierc20metadata++`-link:https://github.com/openzeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc20.cairo[pass:[<svg-class="icon"><use-href="#github-icon"/></svg>],role=heading-link]).

<Callout>
See [Hooks](#hooks) to understand how are hooks used.
</Callout>

**Hooks**

<a name="ERC20Component-ERC20HooksTrait"></a>**ERC20HooksTrait**

* [`+before_update(self, from, recipient, amount)+`](#`[.contract-item-name]#++before_update++#++(ref-self:-contractstate,-from:-contractaddress,-recipient:-contractaddress,-amount:-u256)++`-[.item-kind]#hook#)
* [`+after_update(self, from, recipient, amount)+`](#`[.contract-item-name]#++after_update++#++(ref-self:-contractstate,-from:-contractaddress,-recipient:-contractaddress,-amount:-u256)++`-[.item-kind]#hook#)

<a name="ERC20Component-Embeddable-Mixin-Impl"></a>**mixin-impls**

**ERC20MixinImpl**

* [`+ERC20Impl+`](#ERC20Component-Embeddable-Impls-ERC20Impl)
* [`+ERC20MetadataImpl+`](#ERC20Component-Embeddable-Impls-ERC20MetadataImpl)
* [`+ERC20CamelOnlyImpl+`](#ERC20Component-Embeddable-Impls-ERC20CamelOnlyImpl)

<a name="ERC20Component-Embeddable-Impls"></a>**Embeddable Implementations**

<a name="ERC20Component-Embeddable-Impls-ERC20Impl"></a>**ERC20Impl**

* [`+total_supply(self)+`](#`[.contract-item-name]#++total_supply++#++(@self:-contractstate)-‚Üí-u256++`-[.item-kind]#external#)
* [`+balance_of(self, account)+`](#`[.contract-item-name]#++balance_of++#++(@self:-contractstate,-account:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+allowance(self, owner, spender)+`](#`[.contract-item-name]#++allowance++#++(@self:-contractstate,-owner:-contractaddress,-spender:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+transfer(self, recipient, amount)+`](#`[.contract-item-name]#++transfer++#++(ref-self:-contractstate,-recipient:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#)
* [`+transfer_from(self, sender, recipient, amount)+`](#`[.contract-item-name]#++transfer_from++#++(ref-self:-contractstate,-sender:-contractaddress,-recipient:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#)
* [`+approve(self, spender, amount)+`](#`[.contract-item-name]#++approve++#++(ref-self:-contractstate,-spender:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#)

<a name="ERC20Component-Embeddable-Impls-ERC20MetadataImpl"></a>**ERC20MetadataImpl**

* [`+name(self)+`](#`[.contract-item-name]#++name++#++()-‚Üí-bytearray++`-[.item-kind]#external#)
* [`+symbol(self)+`](#`[.contract-item-name]#++symbol++#++()-‚Üí-bytearray++`-[.item-kind]#external#)
* [`+decimals(self)+`](#`[.contract-item-name]#++decimals++#++()-‚Üí-u8++`-[.item-kind]#external#)

<a name="ERC20Component-Embeddable-Impls-ERC20CamelOnlyImpl"></a>**ERC20CamelOnlyImpl**

* [`+totalSupply(self)+`](#`[.contract-item-name]#++totalsupply++#++(self:-@contractstate)-‚Üí-u256++`-[.item-kind]#external#)
* [`+balanceOf(self, account)+`](#`[.contract-item-name]#++balanceof++#++(self:-@contractstate,-account:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+transferFrom(self, sender, recipient, amount)+`](#`[.contract-item-name]#++transferfrom++#++(ref-self:-contractstate,-sender:-contractaddress,-recipient:-contractaddress)-‚Üí-bool++`-[.item-kind]#external#)

<a name="ERC20Component-Embeddable-Impls-ERC20PermitImpl"></a>**ERC20PermitImpl**

* [`+permit(self, owner, spender, amount, deadline, signature)+`](#`[.contract-item-name]#++permit++#++(ref-self:-contractstate,-owner:-contractaddress,-spender:-contractaddress,-amount:-u256,-deadline:-u64,-signature:-span<felt252>)-‚Üí-bool++`-[.item-kind]#external#)
* [`+nonces(self, owner)+`](#`[.contract-item-name]#++nonces++#++(self:-@contractstate,-owner:-contractaddress)-‚Üí-felt252++`-[.item-kind]#external#)
* [`+DOMAIN_SEPARATOR(self)+`](#`[.contract-item-name]#++domain_separator++#++(self:-@contractstate)-‚Üí-felt252++`-[.item-kind]#external#)

<a name="ERC20Component-Embeddable-Impls-SNIP12MetadataExternalImpl"></a>**SNIP12MetadataExternalImpl**

* [`+snip12_metadata(self)+`](#`[.contract-item-name]#++snip12_metadata++#++(self:-@contractstate)-‚Üí-(felt252,-felt252)++`-[.item-kind]#external#)

**Internal implementations**

**InternalImpl**

* [`+initializer(self, name, symbol)+`](#`[.contract-item-name]#++initializer++#++(ref-self:-contractstate,-name:-bytearray,-symbol:-bytearray)++`-[.item-kind]#internal#)
* [`+mint(self, recipient, amount)+`](#`[.contract-item-name]#++mint++#++(ref-self:-contractstate,-recipient:-contractaddress,-amount:-u256)++`-[.item-kind]#internal#)
* [`+burn(self, account, amount)+`](#`[.contract-item-name]#++burn++#++(ref-self:-contractstate,-account:-contractaddress,-amount:-u256)++`-[.item-kind]#internal#)
* [`+update(self, from, to, amount)+`](#`[.contract-item-name]#++update++#++(ref-self:-contractstate,-from:-contractaddress,-to:-contractaddress,-amount:-u256)++`-[.item-kind]#internal#)
* [`+_transfer(self, sender, recipient, amount)+`](#`[.contract-item-name]#++_transfer++#++(ref-self:-contractstate,-sender:-contractaddress,-recipient:-contractaddress,-amount:-u256)++`-[.item-kind]#internal#)
* [`+_approve(self, owner, spender, amount)+`](#`[.contract-item-name]#++_approve++#++(ref-self:-contractstate,-owner:-contractaddress,-spender:-contractaddress,-amount:-u256)++`-[.item-kind]#internal#)
* [`+_spend_allowance(self, owner, spender, amount)+`](#`[.contract-item-name]#++_spend_allowance++#++(ref-self:-contractstate,-owner:-contractaddress,-spender:-contractaddress,-amount:-u256)++`-[.item-kind]#internal#)

**Events**

* [`+Transfer(from, to, value)+`](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-value:-u256)++`-[.item-kind]#event#)
* [`+Approval(owner, spender, value)+`](#`[.contract-item-name]#++approval++#++(owner:-contractaddress,-spender:-contractaddress,-value:-u256)++`-[.item-kind]#event#)

#### Hooks

Hooks are functions which implementations can extend the functionality of the component source code. Every contract
using ERC20Component is expected to provide an implementation of the ERC20HooksTrait. For basic token contracts, an
empty implementation with no logic must be provided.

<Callout>
You can use `openzeppelin_token::erc20::ERC20HooksEmptyImpl` which is already available as part of the library
</Callout>
for this purpose.

#### `[.contract-item-name]#++before_update++#++(ref self: ContractState, from: ContractAddress, recipient: ContractAddress, amount: u256)++` [.item-kind]#hook#

Function executed at the beginning of the [update](#`[.contract-item-name]#++update++#++(ref-self:-contractstate,-from:-contractaddress,-to:-contractaddress,-amount:-u256)++`-[.item-kind]#internal#) function prior to any other logic.

#### `[.contract-item-name]#++after_update++#++(ref self: ContractState, from: ContractAddress, recipient: ContractAddress, amount: u256)++` [.item-kind]#hook#

Function executed at the end of the [update](#`[.contract-item-name]#++update++#++(ref-self:-contractstate,-from:-contractaddress,-to:-contractaddress,-amount:-u256)++`-[.item-kind]#internal#) function.

#### Embeddable functions

#### `[.contract-item-name]#++total_supply++#++(@self: ContractState) ‚Üí u256++` [.item-kind]#external#

See [IERC20::total_supply](#`[.contract-item-name]#++total_supply++#++()-‚Üí-u256++`-[.item-kind]#external#).

#### `[.contract-item-name]#++balance_of++#++(@self: ContractState, account: ContractAddress) ‚Üí u256++` [.item-kind]#external#

See [IERC20::balance_of](#`[.contract-item-name]#++balance_of++#++(account:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#).

#### `[.contract-item-name]#++allowance++#++(@self: ContractState, owner: ContractAddress, spender: ContractAddress) ‚Üí u256++` [.item-kind]#external#

See [IERC20::allowance](#`[.contract-item-name]#++allowance++#++(owner:-contractaddress,-spender:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#).

#### `[.contract-item-name]#++transfer++#++(ref self: ContractState, recipient: ContractAddress, amount: u256) ‚Üí bool++` [.item-kind]#external#

See [IERC20::transfer](#`[.contract-item-name]#++transfer++#++(recipient:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#).

Requirements:

* `recipient` cannot be the zero address.
* The caller must have a balance of at least `amount`.

#### `[.contract-item-name]#++transfer_from++#++(ref self: ContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256) ‚Üí bool++` [.item-kind]#external#

See [IERC20::transfer_from](#`[.contract-item-name]#++transfer_from++#++(sender:-contractaddress,-recipient:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#).

Requirements:

* `sender` cannot be the zero address.
* `sender` must have a balance of at least `amount`.
* `recipient` cannot be the zero address.
* The caller must have allowance for ``sender`‚Äôs tokens of at least `amount`.

#### `[.contract-item-name]#++approve++#++(ref self: ContractState, spender: ContractAddress, amount: u256) ‚Üí bool++` [.item-kind]#external#

See [IERC20::approve](#`[.contract-item-name]#++approve++#++(spender:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#).

Requirements:

* `spender` cannot be the zero address.

#### `[.contract-item-name]#++name++#++() ‚Üí ByteArray++` [.item-kind]#external#

See [IERC20Metadata::name](#`[.contract-item-name]#++name++#++()-‚Üí-bytearray++`-[.item-kind]#external#).

#### `[.contract-item-name]#++symbol++#++() ‚Üí ByteArray++` [.item-kind]#external#

See [IERC20Metadata::symbol](#`[.contract-item-name]#++symbol++#++()-‚Üí-bytearray++`-[.item-kind]#external#).

#### `[.contract-item-name]#++decimals++#++() ‚Üí u8++` [.item-kind]#external#

See [IERC20Metadata::decimals](#`[.contract-item-name]#++decimals++#++()-‚Üí-u8++`-[.item-kind]#external#).

#### `[.contract-item-name]#++totalSupply++#++(self: @ContractState) ‚Üí u256++` [.item-kind]#external#

See [IERC20::total_supply](#`[.contract-item-name]#++total_supply++#++()-‚Üí-u256++`-[.item-kind]#external#).

Supports the Cairo v0 convention of writing external methods in camelCase as discussed [here](https://github.com/OpenZeppelin/cairo-contracts/discussions/34).

#### `[.contract-item-name]#++balanceOf++#++(self: @ContractState, account: ContractAddress) ‚Üí u256++` [.item-kind]#external#

See [IERC20::balance_of](#`[.contract-item-name]#++balance_of++#++(account:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#).

Supports the Cairo v0 convention of writing external methods in camelCase as discussed [here](https://github.com/OpenZeppelin/cairo-contracts/discussions/34).

#### `[.contract-item-name]#++transferFrom++#++(ref self: ContractState, sender: ContractAddress, recipient: ContractAddress) ‚Üí bool++` [.item-kind]#external#

See [IERC20::transfer_from](#`[.contract-item-name]#++transfer_from++#++(sender:-contractaddress,-recipient:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#).

Supports the Cairo v0 convention of writing external methods in camelCase as discussed [here](https://github.com/OpenZeppelin/cairo-contracts/discussions/34).

#### `[.contract-item-name]#++permit++#++(ref self: ContractState, owner: ContractAddress, spender: ContractAddress, amount: u256, deadline: u64, signature: Span<felt252>) ‚Üí bool++` [.item-kind]#external#

Sets `amount` as the allowance of `spender` over ``owner`‚Äôs tokens after validating the
signature.

Requirements:

* `owner` is a deployed account contract.
* `spender` is not the zero address.
* `deadline` is not a timestamp in the past.
* `signature` is a valid signature that can be validated with a call to `owner` account.
* `signature` must use the current nonce of the `owner`.

Emits an [Approval](#ERC20-Approval) event.
Every successful call increases `owner‚Äôs nonce by one.

#### `[.contract-item-name]#++nonces++#++(self: @ContractState, owner: ContractAddress) ‚Üí felt252++` [.item-kind]#external#

Returns the current nonce of `owner`. A nonce value must be included
whenever a signature for `permit` call is generated.

#### `[.contract-item-name]#++DOMAIN_SEPARATOR++#++(self: @ContractState) ‚Üí felt252++` [.item-kind]#external#

Returns the domain separator used in generating a message hash for `permit` signature.
The domain hashing logic follows the [SNIP12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) standard.

#### `[.contract-item-name]#++snip12_metadata++#++(self: @ContractState) ‚Üí (felt252, felt252)++` [.item-kind]#external#

Returns the domain name and version used to generate the message hash for permit signature.

The returned tuple contains:

* `t.0`: The name used in the [SNIP12Metadata](api/utilities.adoc#snip12) implementation.
* `t.1`: The version used in the [SNIP12Metadata](api/utilities.adoc#snip12) implementation.

#### Internal functions

#### `[.contract-item-name]#++initializer++#++(ref self: ContractState, name: ByteArray, symbol: ByteArray)++` [.item-kind]#internal#

Initializes the contract by setting the token name and symbol.
This should be used inside of the contract‚Äôs constructor.

#### `[.contract-item-name]#++mint++#++(ref self: ContractState, recipient: ContractAddress, amount: u256)++` [.item-kind]#internal#

Creates an `amount` number of tokens and assigns them to `recipient`.

Emits a [Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-value:-u256)++`-[.item-kind]#event#) event with `from` being the zero address.

Requirements:

* `recipient` cannot be the zero address.

#### `[.contract-item-name]#++burn++#++(ref self: ContractState, account: ContractAddress, amount: u256)++` [.item-kind]#internal#

Destroys `amount` number of tokens from `account`.

Emits a [Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-value:-u256)++`-[.item-kind]#event#) event with `to` set to the zero address.

Requirements:

* `account` cannot be the zero address.

#### `[.contract-item-name]#++update++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, amount: u256)++` [.item-kind]#internal#

Transfers an `amount` of tokens from `from` to `to`, or alternatively mints (or burns) if `from` (or `to`) is
the zero address.

<Callout>
This function can be extended using the [ERC20HooksTrait](#ERC20Component-ERC20HooksTrait), to add
</Callout>
functionality before and/or after the transfer, mint, or burn.

Emits a [Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-value:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++_transfer++#++(ref self: ContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256)++` [.item-kind]#internal#

Moves `amount` of tokens from `from` to `to`.

This internal function does not check for access permissions but can be useful as a building block, for example to implement automatic token fees, slashing mechanisms, etc.

Emits a [Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-value:-u256)++`-[.item-kind]#event#) event.

Requirements:

* `from` cannot be the zero address.
* `to` cannot be the zero address.
* `from` must have a balance of at least `amount`.

#### `[.contract-item-name]#++_approve++#++(ref self: ContractState, owner: ContractAddress, spender: ContractAddress, amount: u256)++` [.item-kind]#internal#

Sets `amount` as the allowance of `spender` over ``owner`‚Äôs tokens.

This internal function does not check for access permissions but can be useful as a building block, for example to implement automatic allowances on behalf of other addresses.

Emits an [Approval](#`[.contract-item-name]#++approval++#++(owner:-contractaddress,-spender:-contractaddress,-value:-u256)++`-[.item-kind]#event#) event.

Requirements:

* `owner` cannot be the zero address.
* `spender` cannot be the zero address.

#### `[.contract-item-name]#++_spend_allowance++#++(ref self: ContractState, owner: ContractAddress, spender: ContractAddress, amount: u256)++` [.item-kind]#internal#

Updates ``owner`‚Äôs allowance for `spender` based on spent `amount`.

This internal function does not update the allowance value in the case of infinite allowance.

Possibly emits an [Approval](#`[.contract-item-name]#++approval++#++(owner:-contractaddress,-spender:-contractaddress,-value:-u256)++`-[.item-kind]#event#) event.

#### Events

#### `[.contract-item-name]#++Transfer++#++(from: ContractAddress, to: ContractAddress, value: u256)++` [.item-kind]#event#

See [IERC20::Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-value:-u256)++`-[.item-kind]#event#).

#### `[.contract-item-name]#++Approval++#++(owner: ContractAddress, spender: ContractAddress, value: u256)++` [.item-kind]#event#

See [IERC20::Approval](#`[.contract-item-name]#++approval++#++(owner:-contractaddress,-spender:-contractaddress,-value:-u256)++`-[.item-kind]#event#).

## Extensions

### `++ERC4626Component++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/token/src/erc20/extensions/erc4626/interface.cairo#L19[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

```rust
use openzeppelin_token::erc20::extensions::erc4626::ERC4626Component;
```

Extension of ERC20 that implements the [IERC4626](#`++ierc4626++`-link:https://github.com/openzeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc4626.cairo[pass:[<svg-class="icon"><use-href="#github-icon"/></svg>],role=heading-link]) interface which allows the minting and burning of "shares" in exchange for an underlying "asset."
The component leverages traits to configure fees, limits, and decimals.

**üî• CAUTION**\
Note on hooks. Special care must be taken when calling external contracts from them. In
that case, consider implementing reentrancy protections. For example, in the
`withdraw` flow, the `withdraw_limit` is checked **before** the `before_withdraw` hook
is invoked. If this hook performs a reentrant call that invokes `withdraw` again, the
subsequent check on `withdraw_limit` will be done before the first withdrawal‚Äôs core logic
(e.g., burning shares and transferring assets) is executed. This could
lead to bypassing withdrawal constraints or draining funds.

**immutable-config**

**constants**

* [`+UNDERLYING_DECIMALS+`](#`[.contract-item-name]#++underlying_decimals:++#++-u128++`-[.item-kind]#constant#)
* [`+DECIMALS_OFFSET+`](#`[.contract-item-name]#++decimals_offset:++#++-u128++`-[.item-kind]#constant#)

**functions**

* [`+validate()+`](#`[.contract-item-name]#++validate++#++()++`-[.item-kind]#internal#)

**Hooks**

<a name="ERC4626Component-FeeConfigTrait"></a>**FeeConfigTrait**

* [`+adjust_deposit(self, assets)+`](#`[.contract-item-name]#++adjust_deposit++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#)
* [`+adjust_mint(self, assets)+`](#`[.contract-item-name]#++adjust_mint++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#)
* [`+adjust_withdraw(self, assets)+`](#`[.contract-item-name]#++adjust_withdraw++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#)
* [`+adjust_redeem(self, assets)+`](#`[.contract-item-name]#++adjust_redeem++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#)

<a name="ERC4626Component-LimitConfigTrait"></a>**LimitConfigTrait**

* [`+deposit_limit(self, receiver)+`](#`[.contract-item-name]#++deposit_limit++#++(ref-self:-contractstate,-receiver:-contractaddress)-->-option<u256>++`-[.item-kind]#hook#)
* [`+mint_limit(self, receiver)+`](#`[.contract-item-name]#++mint_limit++#++(ref-self:-contractstate,-receiver:-contractaddress)-->-option<u256>++`-[.item-kind]#hook#)
* [`+withdraw_limit(self, owner)+`](#`[.contract-item-name]#++withdraw_limit++#++(ref-self:-contractstate,-owner:-contractaddress)-->-option<u256>++`-[.item-kind]#hook#)
* [`+redeem_limit(self, owner)+`](#`[.contract-item-name]#++redeem_limit++#++(ref-self:-contractstate,-owner:-contractaddress)-->-option<u256>++`-[.item-kind]#hook#)

<a name="ERC4626Component-ERC4626HooksTrait"></a>**ERC4626HooksTrait**

* [`+before_withdraw(self, assets, shares)+`](#`[.contract-item-name]#++before_withdraw++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#)
* [`+after_withdraw(self, assets, shares)+`](#`[.contract-item-name]#++after_withdraw++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#)
* [`+before_deposit(self, assets, shares)+`](#`[.contract-item-name]#++before_deposit++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#)
* [`+after_deposit(self, assets, shares)+`](#`[.contract-item-name]#++after_deposit++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#)

<a name="ERC4626Component-Embeddable-Impls"></a>**Embeddable Implementations**

**ERC4626Impl**

* [`+asset(self)+`](#`[.contract-item-name]#++asset++#++(self:-@contractstate)-‚Üí-contractaddress++`-[.item-kind]#external#)
* [`+total_assets(self)+`](#`[.contract-item-name]#++total_assets++#++(self:-@contractstate)-‚Üí-u256++`-[.item-kind]#external#)
* [`+convert_to_shares(self, assets)+`](#`[.contract-item-name]#++convert_to_shares++#++(self:-@contractstate,-assets:-u256)-‚Üí-u256++`-[.item-kind]#external#)
* [`+convert_to_assets(self, shares)+`](#`[.contract-item-name]#++convert_to_assets++#++(self:-@contractstate,-shares:-u256)-‚Üí-u256++`-[.item-kind]#external#)
* [`+max_deposit(self, receiver)+`](#`[.contract-item-name]#++max_deposit++#++(self:-@contractstate,-receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+preview_deposit(self, assets)+`](#`[.contract-item-name]#++preview_deposit++#++(self:-@contractstate,-assets:-u256)-‚Üí-u256++`-[.item-kind]#external#)
* [`+deposit(self, assets, receiver)+`](#`[.contract-item-name]#++deposit++#++(ref-self:-contractstate,-assets:-u256,-receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+max_mint(self, receiver)+`](#`[.contract-item-name]#++max_mint++#++(self:-@contractstate,-receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+preview_mint(self, shares)+`](#`[.contract-item-name]#++preview_mint++#++(self:-@contractstate,-shares:-u256)-‚Üí-u256++`-[.item-kind]#external#)
* [`+mint(self, shares, receiver)+`](#`[.contract-item-name]#++mint++#++(self:-@contractstate,-shares:-u256,-receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+max_withdraw(self, owner)+`](#`[.contract-item-name]#++max_withdraw++#++(self:-@contractstate,-owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+preview_withdraw(self, assets)+`](#`[.contract-item-name]#++preview_withdraw++#++(self:-@contractstate,-assets:-u256)-‚Üí-u256++`-[.item-kind]#external#)
* [`+withdraw(self, assets, receiver, owner)+`](#`[.contract-item-name]#++withdraw++#++(self:-@contractstate,-assets:-u256,-receiver:-contractaddress,-owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+max_redeem(self, owner)+`](#`[.contract-item-name]#++max_redeem++#++(self:-@contractstate,-owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+preview_redeem(self, shares)+`](#`[.contract-item-name]#++preview_redeem++#++(self:-@contractstate,-shares:-u256)-‚Üí-u256++`-[.item-kind]#external#)
* [`+redeem(self, shares, receiver, owner)+`](#`[.contract-item-name]#++redeem++#++(self:-@contractstate,-shares:-u256,-receiver:-contractaddress,-owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)

**ERC20Impl**

* [`+total_supply(self)+`](#`[.contract-item-name]#++total_supply++#++(@self:-contractstate)-‚Üí-u256++`-[.item-kind]#external#)
* [`+balance_of(self, account)+`](#`[.contract-item-name]#++balance_of++#++(@self:-contractstate,-account:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+allowance(self, owner, spender)+`](#`[.contract-item-name]#++allowance++#++(@self:-contractstate,-owner:-contractaddress,-spender:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#)
* [`+transfer(self, recipient, amount)+`](#`[.contract-item-name]#++transfer++#++(ref-self:-contractstate,-recipient:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#)
* [`+transfer_from(self, sender, recipient, amount)+`](#`[.contract-item-name]#++transfer_from++#++(ref-self:-contractstate,-sender:-contractaddress,-recipient:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#)
* [`+approve(self, spender, amount)+`](#`[.contract-item-name]#++approve++#++(ref-self:-contractstate,-spender:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#)

**ERC4626MetadataImpl**

* [`+name(self)+`](#`[.contract-item-name]#++name++#++(self:-@contractstate)-‚Üí-bytearray++`-[.item-kind]#external#)
* [`+symbol(self)+`](#`[.contract-item-name]#++symbol++#++(self:-@contractstate)-‚Üí-bytearray++`-[.item-kind]#external#)
* [`+decimals(self)+`](#`[.contract-item-name]#++decimals++#++(self:-@contractstate)-‚Üí-u8++`-[.item-kind]#external#)

**Internal functions**

**InternalImpl**

* [`+initializer(self, asset_address)+`](#`[.contract-item-name]#++initializer++#++(ref-self:-contractstate,-asset_address:-contractaddress)++`-[.item-kind]#internal#)
* [`+_deposit(self, caller, receiver, assets, shares)+`](#`[.contract-item-name]#++_deposit++#++(ref-self:-contractstate,-caller:-contractaddress,-receiver:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#internal#)
* [`+_withdraw(self, caller, receiver, owner, assets, shares)+`](#`[.contract-item-name]#++_withdraw++#++(ref-self:-contractstate,-caller:-contractaddress,-receiver:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#internal#)
* [`+_convert_to_shares(self, assets, rounding)+`](#`[.contract-item-name]#++_convert_to_shares++#++(self:-@contractstate,-assets:-u256,-rounding:-rounding)-->-u256++`-[.item-kind]#internal#)
* [`+_convert_to_assets(self, shares, rounding)+`](#`[.contract-item-name]#++_convert_to_assets++#++(self:-@contractstate,-shares:-u256,-rounding:-rounding)-->-u256++`-[.item-kind]#internal#)

#### Immutable Config

#### `[.contract-item-name]#++UNDERLYING_DECIMALS:++#++ u128++` [.item-kind]#constant#

Should match the underlying asset‚Äôs decimals.
The default value is `18`.

#### `[.contract-item-name]#++DECIMALS_OFFSET:++#++ u128++` [.item-kind]#constant#

Corresponds to the representational offset between `UNDERLYING_DECIMALS` and the vault decimals.
The greater the offset, the more expensive it is for attackers to execute an inflation attack.

#### `[.contract-item-name]#++validate++#++()++` [.item-kind]#internal#

Validates the given implementation of the contract‚Äôs configuration.

Requirements:

* `UNDERLYING_DECIMALS`  + `DECIMALS_OFFSET` cannot exceed 255 (max u8).

<Callout>
This function is called by the contract‚Äôs initializer.
</Callout>

#### Hooks

Hooks are functions which implementations can extend the functionality of the component source code.
Every contract using ERC4626Component is expected to provide an implementation of the ERC4626HooksTrait.
For basic token contracts, an empty implementation with no logic must be provided.

<Callout>
You can use `openzeppelin_token::erc20::extensions::erc4626::ERC4626HooksEmptyImpl` which is already available as part of the library for this purpose.
</Callout>

#### FeeConfigTrait

Adjustments for fees expected to be defined at the contract level.
Defaults to no entry or exit fees.

<Callout>
The FeeConfigTrait hooks directly into the preview methods of the ERC4626 component.
</Callout>
The preview methods must return as close to the exact amount of shares or assets as possible if the actual (previewed) operation occurred in the same transaction (according to [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec).
All operations use their corresponding preview method as the value of assets or shares being moved.
Therefore, adjusting an operation‚Äôs assets in FeeConfigTrait consequently adjusts the assets (or assets to be converted into shares) in both the preview operation and the actual operation.

<Callout>
To transfer fees, this trait needs to be coordinated with `ERC4626Component::ERC4626Hooks`.
</Callout>
See the [ERC4626FeesMock example](https://github.com/OpenZeppelin/cairo-contracts/tree/main/packages/test_common/src/mocks/erc4626.cairo).

#### `[.contract-item-name]#++adjust_deposit++#++(ref self: ContractState, assets: u256, shares: u256)++` [.item-kind]#hook#

Adjusts deposits within [preview_deposit](#`[.contract-item-name]#++preview_deposit++#++(self:-@contractstate,-assets:-u256)-‚Üí-u256++`-[.item-kind]#external#) to account for entry fees.
Entry fees should be transferred in the [after_deposit](#`[.contract-item-name]#++after_deposit++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#) hook.

#### `[.contract-item-name]#++adjust_mint++#++(ref self: ContractState, assets: u256, shares: u256)++` [.item-kind]#hook#

Adjusts deposits within [preview_mint](#`[.contract-item-name]#++preview_mint++#++(self:-@contractstate,-shares:-u256)-‚Üí-u256++`-[.item-kind]#external#) to account for entry fees.
Entry fees should be transferred in the [after_deposit](#`[.contract-item-name]#++after_deposit++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#) hook.

#### `[.contract-item-name]#++adjust_withdraw++#++(ref self: ContractState, assets: u256, shares: u256)++` [.item-kind]#hook#

Adjusts withdraws within [preview_withdraw](#`[.contract-item-name]#++preview_withdraw++#++(self:-@contractstate,-assets:-u256)-‚Üí-u256++`-[.item-kind]#external#) to account for exit fees.
Exit fees should be transferred in the [before_withdraw](#`[.contract-item-name]#++before_withdraw++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#) hook.

#### `[.contract-item-name]#++adjust_redeem++#++(ref self: ContractState, assets: u256, shares: u256)++` [.item-kind]#hook#

Adjusts withdraws within [preview_redeem](#`[.contract-item-name]#++preview_redeem++#++(self:-@contractstate,-shares:-u256)-‚Üí-u256++`-[.item-kind]#external#) to account for exit fees.
Exit fees should be transferred in the [before_withdraw](#`[.contract-item-name]#++before_withdraw++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#) hook.

#### LimitConfigTrait

Sets limits to the target exchange type and is expected to be defined at the contract
level. These limits correspond directly to the `max_<OPERATION>` i.e. `deposit_limit` -> `max_deposit`.

<Callout>
The [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec states that the `max_<OPERATION>` methods must take into account all
</Callout>
global and user-specific limits.
If an operation is disabled (even temporarily), the corresponding limit MUST be `0`
and MUST NOT panic.

#### `[.contract-item-name]#++deposit_limit++#++(ref self: ContractState, receiver: ContractAddress) -> Option<u256>++` [.item-kind]#hook#

The max deposit allowed.

Defaults (`Option::None`) to 2 ** 256 - 1.

#### `[.contract-item-name]#++mint_limit++#++(ref self: ContractState, receiver: ContractAddress) -> Option<u256>++` [.item-kind]#hook#

The max mint allowed.

Defaults (`Option::None`) to 2 ** 256 - 1.

#### `[.contract-item-name]#++withdraw_limit++#++(ref self: ContractState, owner: ContractAddress) -> Option<u256>++` [.item-kind]#hook#

The max withdraw allowed.

Defaults (`Option::None`) to the full asset balance of `owner` converted from shares.

#### `[.contract-item-name]#++redeem_limit++#++(ref self: ContractState, owner: ContractAddress) -> Option<u256>++` [.item-kind]#hook#

The max redeem allowed.

Defaults (`Option::None`) to the full asset balance of `owner`.

#### ERC4626HooksTrait

Allows contracts to hook logic into deposit and withdraw transactions.
This is where contracts can transfer fees.

<Callout>
ERC4626 preview methods must be inclusive of any entry or exit fees.
</Callout>
The `AdjustFeesTrait` will adjust these values accordingly; therefore,
fees must be set in the `AdjustFeesTrait` if the using contract enforces entry or exit fees.
See the [ERC4626FeesMock example](https://github.com/OpenZeppelin/cairo-contracts/tree/main/packages/test_common/src/mocks/erc4626.cairo).

#### `[.contract-item-name]#++before_withdraw++#++(ref self: ContractState, assets: u256, shares: u256)++` [.item-kind]#hook#

Hooks into [_withdraw](#`[.contract-item-name]#++_withdraw++#++(ref-self:-contractstate,-caller:-contractaddress,-receiver:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#internal#).

Executes logic before burning shares and transferring assets.

#### `[.contract-item-name]#++after_withdraw++#++(ref self: ContractState, assets: u256, shares: u256)++` [.item-kind]#hook#

Hooks into [_withdraw](#`[.contract-item-name]#++_withdraw++#++(ref-self:-contractstate,-caller:-contractaddress,-receiver:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#internal#).

Executes logic after burning shares and transferring assets.

#### `[.contract-item-name]#++before_deposit++#++(ref self: ContractState, assets: u256, shares: u256)++` [.item-kind]#hook#

Hooks into [_deposit](#`[.contract-item-name]#++_deposit++#++(ref-self:-contractstate,-caller:-contractaddress,-receiver:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#internal#).

Executes logic before transferring assets and minting shares.

#### `[.contract-item-name]#++after_deposit++#++(ref self: ContractState, assets: u256, shares: u256)++` [.item-kind]#hook#

Hooks into [_deposit](#`[.contract-item-name]#++_deposit++#++(ref-self:-contractstate,-caller:-contractaddress,-receiver:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#internal#).

Executes logic after transferring assets and minting shares.

#### Embeddable functions

#### `[.contract-item-name]#++asset++#++(self: @ContractState) ‚Üí ContractAddress++` [.item-kind]#external#

Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.

#### `[.contract-item-name]#++total_assets++#++(self: @ContractState) ‚Üí u256++` [.item-kind]#external#

Returns the total amount of the underlying asset that is ‚Äúmanaged‚Äù by Vault.

#### `[.contract-item-name]#++convert_to_shares++#++(self: @ContractState, assets: u256) ‚Üí u256++` [.item-kind]#external#

Returns the amount of shares that the Vault would exchange for the amount of assets provided irrespective of slippage or fees.

<Callout>
As per the [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec, this may panic _only_ if there‚Äôs an overflow from an unreasonably large input.
</Callout>

#### `[.contract-item-name]#++convert_to_assets++#++(self: @ContractState, shares: u256) ‚Üí u256++` [.item-kind]#external#

Returns the amount of assets that the Vault would exchange for the amount of shares provided irrespective of slippage or fees.

<Callout>
As per the [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec, this may panic _only_ if there‚Äôs an overflow from an unreasonably large input.
</Callout>

#### `[.contract-item-name]#++max_deposit++#++(self: @ContractState, receiver: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Returns the maximum amount of the underlying asset that can be deposited into the Vault for the `receiver`, through a [deposit](#`[.contract-item-name]#++deposit++#++(ref-self:-contractstate,-assets:-u256,-receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#) call.

The default max deposit value is 2 ** 256 - 1.

This can be changed in the implementing contract by defining custom logic in
[LimitConfigTrait::deposit_limit](#`[.contract-item-name]#++deposit_limit++#++(ref-self:-contractstate,-receiver:-contractaddress)-->-option<u256>++`-[.item-kind]#hook#).

#### `[.contract-item-name]#++preview_deposit++#++(self: @ContractState, assets: u256) ‚Üí u256++` [.item-kind]#external#

Allows an on-chain or off-chain user to simulate the effects of their deposit at the
current block, given current on-chain conditions.

The default deposit preview value is the full amount of shares.
This can be changed to account for fees, for example, in the implementing contract by
defining custom logic in [LimitConfigTrait::adjust_deposit](#`[.contract-item-name]#++adjust_deposit++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#).

<Callout>
This method must be inclusive of entry fees to be compliant with the [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec.
</Callout>

#### `[.contract-item-name]#++deposit++#++(ref self: ContractState, assets: u256, receiver: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Mints Vault shares to `receiver` by depositing exactly `assets` of underlying tokens.
Returns the amount of newly-minted shares.

Requirements:

* `assets` is less than or equal to the max deposit amount for `receiver`.

Emits a [Deposit](#`[.contract-item-name]#++deposit++#++(sender:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++max_mint++#++(self: @ContractState, receiver: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Returns the maximum amount of the Vault shares that can be minted for `receiver` through
a [mint](#`[.contract-item-name]#++mint++#++(self:-@contractstate,-shares:-u256,-receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#) call.

The default max mint value is 2 ** 256 - 1.

This can be changed in the implementing contract by defining custom logic in [LimitConfigTrait::mint_limit](#`[.contract-item-name]#++mint_limit++#++(ref-self:-contractstate,-receiver:-contractaddress)-->-option<u256>++`-[.item-kind]#hook#).

#### `[.contract-item-name]#++preview_mint++#++(self: @ContractState, shares: u256) ‚Üí u256++` [.item-kind]#external#

Allows an on-chain or off-chain user to simulate the effects of their mint at the
current block, given current on-chain conditions.

The default mint preview value is the full amount of assets.
This can be changed to account for fees, for example, in the implementing contract by
defining custom logic in [LimitConfigTrait::adjust_mint](#`[.contract-item-name]#++adjust_mint++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#).

<Callout>
This method must be inclusive of entry fees to be compliant with the [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec.
</Callout>

#### `[.contract-item-name]#++mint++#++(self: @ContractState, shares: u256, receiver: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Mints exactly Vault `shares` to `receiver` by depositing amount of underlying tokens.
Returns the amount deposited assets.

Requirements:

* `shares` is less than or equal to the max shares amount for `receiver`.

Emits a [Deposit](#`[.contract-item-name]#++deposit++#++(sender:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++max_withdraw++#++(self: @ContractState, owner: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Returns the maximum amount of the underlying asset that can be withdrawn from the owner
balance in the Vault, through a [withdraw](#`[.contract-item-name]#++withdraw++#++(self:-@contractstate,-assets:-u256,-receiver:-contractaddress,-owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#) call.

The default max withdraw value is the full balance of assets for `owner` (converted from shares).
This can be changed in the implementing contract by defining custom logic in [LimitConfigTrait::withdraw_limit](#`[.contract-item-name]#++withdraw_limit++#++(ref-self:-contractstate,-owner:-contractaddress)-->-option<u256>++`-[.item-kind]#hook#).

<Callout>
With customized limits, the maximum withdraw amount will either be the custom limit itself
</Callout>
or ``owner`‚Äôs total asset balance, whichever value is less.

#### `[.contract-item-name]#++preview_withdraw++#++(self: @ContractState, assets: u256) ‚Üí u256++` [.item-kind]#external#

Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the
current block, given current on-chain conditions.

The default withdraw preview value is the full amount of shares.
This can be changed to account for fees, for example, in the implementing contract by defining custom logic in [LimitConfigTrait::adjust_withdraw](#`[.contract-item-name]#++adjust_withdraw++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#).

<Callout>
This method must be inclusive of exit fees to be compliant with the [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec.
</Callout>

#### `[.contract-item-name]#++withdraw++#++(self: @ContractState, assets: u256, receiver: ContractAddress, owner: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Burns shares from `owner` and sends exactly `assets` of underlying tokens to `receiver`.

Requirements:

* `assets` is less than or equal to the max withdraw amount of `owner`.

Emits a [Withdraw](#`[.contract-item-name]#++withdraw++#++(sender:-contractaddress,-receiver:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++max_redeem++#++(self: @ContractState, owner: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Returns the maximum amount of Vault shares that can be redeemed from the owner balance
in the Vault, through a [redeem](#`[.contract-item-name]#++redeem++#++(self:-@contractstate,-shares:-u256,-receiver:-contractaddress,-owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#) call.

The default max redeem value is the full balance of assets for `owner`.
This can be changed in the implementing contract by defining custom logic in [LimitConfigTrait::redeem_limit](#`[.contract-item-name]#++redeem_limit++#++(ref-self:-contractstate,-owner:-contractaddress)-->-option<u256>++`-[.item-kind]#hook#).

<Callout>
With customized limits, the maximum redeem amount will either be the custom limit itself
</Callout>
or ``owner`‚Äôs total asset balance, whichever value is less.

#### `[.contract-item-name]#++preview_redeem++#++(self: @ContractState, shares: u256) ‚Üí u256++` [.item-kind]#external#

Allows an on-chain or off-chain user to simulate the effects of their redeemption at the
current block, given current on-chain conditions.

The default redeem preview value is the full amount of assets.
This can be changed to account for fees, for example, in the implementing contract by defining custom logic in [LimitConfigTrait::adjust_redeem](#`[.contract-item-name]#++adjust_redeem++#++(ref-self:-contractstate,-assets:-u256,-shares:-u256)++`-[.item-kind]#hook#).

<Callout>
This method must be inclusive of exit fees to be compliant with the [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec.
</Callout>

#### `[.contract-item-name]#++redeem++#++(self: @ContractState, shares: u256, receiver: ContractAddress, owner: ContractAddress) ‚Üí u256++` [.item-kind]#external#

Burns exactly `shares` from `owner` and sends assets of underlying tokens to `receiver`.

Requirements:

* `shares` is less than or equal to the max redeem amount of `owner`.

Emits a [Withdraw](#`[.contract-item-name]#++withdraw++#++(sender:-contractaddress,-receiver:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++name++#++(self: @ContractState) ‚Üí ByteArray++` [.item-kind]#external#

Returns the name of the token.

#### `[.contract-item-name]#++symbol++#++(self: @ContractState) ‚Üí ByteArray++` [.item-kind]#external#

Returns the ticker symbol of the token, usually a shorter version of the name.

#### `[.contract-item-name]#++decimals++#++(self: @ContractState) ‚Üí u8++` [.item-kind]#external#

Returns the cumulative number of decimals which includes both `UNDERLYING_DECIMALS` and `OFFSET_DECIMALS`.
Both of which must be defined in the [ImmutableConfig](#immutable-config) inside the implementing contract.

#### Internal functions

#### `[.contract-item-name]#++initializer++#++(ref self: ContractState, asset_address: ContractAddress)++` [.item-kind]#internal#

Validates the [ImmutableConfig](#immutable-config) constants and sets the `asset_address` to the vault.
This should be set in the contract‚Äôs constructor.

Requirements:

* `asset_address` cannot be the zero address.

#### `[.contract-item-name]#++_deposit++#++(ref self: ContractState, caller: ContractAddress, receiver: ContractAddress, assets: u256, shares: u256)++` [.item-kind]#internal#

Internal logic for [deposit](#`[.contract-item-name]#++deposit++#++(ref-self:-contractstate,-assets:-u256,-receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#) and [mint](#`[.contract-item-name]#++mint++#++(self:-@contractstate,-shares:-u256,-receiver:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#).

Transfers `assets` from `caller` to the Vault contract then mints `shares` to
`receiver`.
Fees can be transferred in the `ERC4626Hooks::after_deposit` hook which is executed
after assets are transferred and shares are minted.

Requirements:

* [ERC20::transfer_from](#`[.contract-item-name]#++transfer_from++#++(ref-self:-contractstate,-sender:-contractaddress,-recipient:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#) must return true.

Emits two [ERC20::Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-value:-u256)++`-[.item-kind]#event#) events (`ERC20::mint` and `ERC20::transfer_from`).

Emits a [Deposit](#`[.contract-item-name]#++deposit++#++(sender:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++_withdraw++#++(ref self: ContractState, caller: ContractAddress, receiver: ContractAddress, owner: ContractAddress, assets: u256, shares: u256)++` [.item-kind]#internal#

Internal logic for [withdraw](#`[.contract-item-name]#++withdraw++#++(self:-@contractstate,-assets:-u256,-receiver:-contractaddress,-owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#) and [redeem](#`[.contract-item-name]#++redeem++#++(self:-@contractstate,-shares:-u256,-receiver:-contractaddress,-owner:-contractaddress)-‚Üí-u256++`-[.item-kind]#external#).

Burns `shares` from `owner` and then transfers `assets` to `receiver`.
Fees can be transferred in the `ERC4626Hooks::before_withdraw` hook which is executed
before shares are burned and assets are transferred.

Requirements:

* [ERC20::transfer](#`[.contract-item-name]#++transfer++#++(ref-self:-contractstate,-recipient:-contractaddress,-amount:-u256)-‚Üí-bool++`-[.item-kind]#external#) must return true.

Emits two [ERC20::Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-value:-u256)++`-[.item-kind]#event#) events (`ERC20::burn` and `ERC20::transfer`).

Emits a [Withdraw](#`[.contract-item-name]#++withdraw++#++(sender:-contractaddress,-receiver:-contractaddress,-owner:-contractaddress,-assets:-u256,-shares:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++_convert_to_shares++#++(self: @ContractState, assets: u256, rounding: Rounding) -> u256++` [.item-kind]#internal#

Internal conversion function (from assets to shares) with support for `rounding` direction.

#### `[.contract-item-name]#++_convert_to_assets++#++(self: @ContractState, shares: u256, rounding: Rounding) -> u256++` [.item-kind]#internal#

Internal conversion function (from shares to assets) with support for `rounding` direction.

## Presets

### `++ERC20Upgradeable++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/presets/src/erc20.cairo[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

```rust
use openzeppelin_presets::ERC20Upgradeable;
```

Upgradeable ERC20 contract leveraging [ERC20Component](#`++erc20component++`-link:https://github.com/openzeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/token/src/erc20/erc20.cairo[pass:[<svg-class="icon"><use-href="#github-icon"/></svg>],role=heading-link]) with a fixed-supply mechanism for token distribution.

**presets-page**

ERC20Upgradeable-class-hash

**Constructor**

* [`+constructor(self, name, symbol, fixed_supply, recipient, owner)+`](#`[.contract-item-name]#++constructor++#++(ref-self:-contractstate,-name:-bytearray,-symbol:-bytearray,-fixed_supply:-u256,-recipient:-contractaddress,-owner:-contractaddress)++`-[.item-kind]#constructor#)

**Embedded Implementations**

* [`+ERC20MixinImpl+`](#ERC20Component-Embeddable-Mixin-Impl)

* [`+OwnableMixinImpl+`](/api/access.adoc#OwnableComponent-Mixin-Impl)

**External Functions**

* [`+upgrade(self, new_class_hash)+`](#`[.contract-item-name]#++upgrade++#++(ref-self:-contractstate,-new_class_hash:-classhash)++`-[.item-kind]#external#)

#### Constructor

#### `[.contract-item-name]#++constructor++#++(ref self: ContractState, name: ByteArray, symbol: ByteArray, fixed_supply: u256, recipient: ContractAddress, owner: ContractAddress)++` [.item-kind]#constructor#

Sets the `name` and `symbol` and mints `fixed_supply` tokens to `recipient`.
Assigns `owner` as the contract owner with permissions to upgrade.

#### External functions

#### `[.contract-item-name]#++upgrade++#++(ref self: ContractState, new_class_hash: ClassHash)++` [.item-kind]#external#

Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

* The caller is the contract owner.
* `new_class_hash` cannot be zero.
