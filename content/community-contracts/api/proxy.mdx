---
title: "Proxy"
description: "Smart contract proxy utilities and implementations"
---

Variants of proxy patterns, which are contracts that allow to forward a call to an implementation contract by using `delegatecall`. This contracts include:

* [`HybridProxy`](#HybridProxy): An ERC-1967 proxy that uses the implementation slot as a beacon in a way that a user can upgrade to an implementation of their choice.

## General

[`HybridProxy`](#HybridProxy)

<a id="HybridProxy"></a>

<div style={{marginTop: "4em"}} className="w-full flex flex-row items-center justify-between">

## `HybridProxy`

<a target="_blank" style={{marginTop: "1.5em"}} href="https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/proxy/HybridProxy.sol">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github-icon lucide-github"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
</a>

</div>

```solidity
import "@openzeppelin/community-contracts/proxy/HybridProxy.sol";
```

A version of an ERC-1967 proxy that uses the address stored in the implementation slot as a beacon.

The design allows to set an initial beacon that the contract may quit by upgrading to its own implementation
afterwards. Transition between the "beacon mode" and the "direct mode" require implementation that expose an
upgrade mechanism that writes to the ERC-1967 implementation slot. Note that UUPSUpgradable includes security
checks that are not compatible with this proxy design.

<Callout type="warn">
The fallback mechanism relies on the implementation not to define the `IBeacon-implementation` function.
Consider that if your implementation has this function, it'll be assumed as the beacon address, meaning that
the returned address will be used as this proxy's implementation.
</Callout>

<div className="bg-secondary p-4 rounded-md mb-6">
<h3 style={{ marginTop: "0"}}>Functions</h3>
<div className="font-mono">
- [constructor(implementation, data)](#HybridProxy-constructor-address-bytes-)
- [_implementation()](#HybridProxy-_implementation--)
#### Proxy [!toc]
- [_delegate(implementation)](#Proxy-_delegate-address-)
- [_fallback()](#Proxy-_fallback--)
- [fallback()](#Proxy-fallback--)
</div>
</div>

<a id="HybridProxy-constructor-address-bytes-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">constructor(address implementation, bytes data)</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">public</p>
<a className="peer" data-card href="HybridProxy-constructor-address-bytes-">#</a>
</div>
</div>
<div className="px-4">

Initializes the proxy with an initial implementation. If data is present, it will be used to initialize the
implementation using a delegate call.

</div>
</div>

<a id="HybridProxy-_implementation--"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">_implementation() â†’ address</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="HybridProxy-_implementation--">#</a>
</div>
</div>
<div className="px-4">

Returns the current implementation address according to ERC-1967's implementation slot.

<Callout type="warn">
The way this function identifies whether the implementation is a beacon, is by checking
if it implements the `IBeacon-implementation` function. Consider that an actual implementation could
define this function, mistakenly identifying it as a beacon.
</Callout>

</div>
</div>
