---
title: "Cryptography"
description: "Smart contract cryptography utilities and implementations"
---

A collection of contracts and libraries that implement various signature validation schemes and cryptographic primitives. These utilities enable secure authentication, multisignature operations, and advanced cryptographic operations in smart contracts.

* [`ZKEmailUtils`](#ZKEmailUtils): Library for ZKEmail signature validation utilities, enabling email-based authentication through zero-knowledge proofs.
* [`WebAuthn`](#WebAuthn): Library for verifying WebAuthn Authentication Assertions.
* [`DKIMRegistry`](#DKIMRegistry): Implementation of [ERC-7969](https://eips.ethereum.org/EIPS/eip-7969) to enable onchain verification of DomainKeys Identified Mail (DKIM) signatures.
* [`SignerZKEmail`](#SignerZKEmail): Implementation of an [AbstractSigner](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#AbstractSigner) that enables email-based authentication through zero-knowledge proofs.
* [`SignerWebAuthn`](#SignerWebAuthn): Implementation of [SignerP256](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#SignerP256) that supports WebAuthn authentication assertions.
* [`ERC7913ZKEmailVerifier`](#ERC7913ZKEmailVerifier), [`ERC7913WebAuthnVerifier`](#ERC7913WebAuthnVerifier): Ready to use ERC-7913 signature verifiers for ZKEmail and WebAuthn.

## Utils

[`ZKEmailUtils`](#ZKEmailUtils)

[`WebAuthn`](#WebAuthn)

[`DKIMRegistry`](#DKIMRegistry)

## Abstract Signers

[`SignerZKEmail`](#SignerZKEmail)

[`SignerWebAuthn`](#SignerWebAuthn)

## Verifiers

[`ERC7913ZKEmailVerifier`](#ERC7913ZKEmailVerifier)

[`ERC7913WebAuthnVerifier`](#ERC7913WebAuthnVerifier)

<a id="DKIMRegistry"></a>

<div style={{marginTop: "4em"}} className="w-full flex flex-row items-center justify-between">

## `DKIMRegistry`

<a target="_blank" style={{marginTop: "1.5em"}} href="https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/DKIMRegistry.sol">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github-icon lucide-github"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
</a>

</div>

```solidity
import "@openzeppelin/community-contracts/utils/cryptography/DKIMRegistry.sol";
```

Implementation of the [ERC-7969](https://eips.ethereum.org/EIPS/eip-7969) interface for registering
and validating DomainKeys Identified Mail (DKIM) public key hashes onchain.

This contract provides a standard way to register and validate DKIM public key hashes, enabling
email-based account abstraction and secure account recovery mechanisms. Domain owners can register
their DKIM public key hashes and third parties can verify their validity.

The contract stores mappings of domain hashes to DKIM public key hashes, where:

* Domain hash: keccak256 hash of the lowercase domain name
* Key hash: keccak256 hash of the DKIM public key

Example of usage:

```solidity
contract MyDKIMRegistry is DKIMRegistry, Ownable {
    function setKeyHash(bytes32 domainHash, bytes32 keyHash) public onlyOwner {
        _setKeyHash(domainHash, keyHash);
    }

    function setKeyHashes(bytes32 domainHash, bytes32[] memory keyHashes) public onlyOwner {
        _setKeyHashes(domainHash, keyHashes);
    }

    function revokeKeyHash(bytes32 domainHash, bytes32 keyHash) public onlyOwner {
        _revokeKeyHash(domainHash, keyHash);
    }
}
```

<div className="bg-secondary p-4 rounded-md mb-6">
<h3 style={{ marginTop: "0"}}>Functions</h3>
<div className="font-mono">
- [isKeyHashValid(domainHash, keyHash)](#DKIMRegistry-isKeyHashValid-bytes32-bytes32-)
- [_setKeyHash(domainHash, keyHash)](#DKIMRegistry-_setKeyHash-bytes32-bytes32-)
- [_setKeyHashes(domainHash, keyHashes)](#DKIMRegistry-_setKeyHashes-bytes32-bytes32---)
- [_revokeKeyHash(domainHash, keyHash)](#DKIMRegistry-_revokeKeyHash-bytes32-bytes32-)
#### IDKIMRegistry [!toc]
</div>
</div>

<div className="bg-secondary p-4 rounded-md mb-6">
<h3 style={{ marginTop: "0"}}>Events</h3>
<div className="font-mono">
#### IDKIMRegistry [!toc]
- [KeyHashRegistered(domainHash, keyHash)](#IDKIMRegistry-KeyHashRegistered-bytes32-bytes32-)
- [KeyHashRevoked(domainHash)](#IDKIMRegistry-KeyHashRevoked-bytes32-)
</div>
</div>

<a id="DKIMRegistry-isKeyHashValid-bytes32-bytes32-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">isKeyHashValid(bytes32 domainHash, bytes32 keyHash) → bool</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">public</p>
<a className="peer" data-card href="DKIMRegistry-isKeyHashValid-bytes32-bytes32-">#</a>
</div>
</div>
<div className="px-4">

Returns whether a DKIM key hash is valid for a given domain.

</div>
</div>

<a id="DKIMRegistry-_setKeyHash-bytes32-bytes32-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">_setKeyHash(bytes32 domainHash, bytes32 keyHash)</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="DKIMRegistry-_setKeyHash-bytes32-bytes32-">#</a>
</div>
</div>
<div className="px-4">

Sets a DKIM key hash as valid for a domain. Internal version without access control.

Emits a [`IDKIMRegistry.KeyHashRegistered`](../interfaces#IDKIMRegistry-KeyHashRegistered-bytes32-bytes32-) event.

<Callout>
This function does not validate that keyHash is non-zero. Consider adding
validation in derived contracts if needed.
</Callout>

</div>
</div>

<a id="DKIMRegistry-_setKeyHashes-bytes32-bytes32---"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">_setKeyHashes(bytes32 domainHash, bytes32[] keyHashes)</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="DKIMRegistry-_setKeyHashes-bytes32-bytes32---">#</a>
</div>
</div>
<div className="px-4">

Sets multiple DKIM key hashes as valid for a domain in a single transaction.
Internal version without access control.

Emits a [`IDKIMRegistry.KeyHashRegistered`](../interfaces#IDKIMRegistry-KeyHashRegistered-bytes32-bytes32-) event for each key hash.

<Callout>
This function does not validate that the keyHashes array is non-empty.
Consider adding validation in derived contracts if needed.
</Callout>

</div>
</div>

<a id="DKIMRegistry-_revokeKeyHash-bytes32-bytes32-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">_revokeKeyHash(bytes32 domainHash, bytes32 keyHash)</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="DKIMRegistry-_revokeKeyHash-bytes32-bytes32-">#</a>
</div>
</div>
<div className="px-4">

Revokes a DKIM key hash for a domain, making it invalid.
Internal version without access control.

Emits a [`IDKIMRegistry.KeyHashRevoked`](../interfaces#IDKIMRegistry-KeyHashRevoked-bytes32-) event.

</div>
</div>

<a id="WebAuthn"></a>

<div style={{marginTop: "4em"}} className="w-full flex flex-row items-center justify-between">

## `WebAuthn`

<a target="_blank" style={{marginTop: "1.5em"}} href="https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/WebAuthn.sol">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github-icon lucide-github"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
</a>

</div>

```solidity
import "@openzeppelin/community-contracts/utils/cryptography/WebAuthn.sol";
```

Library for verifying WebAuthn Authentication Assertions.

WebAuthn enables strong authentication for smart contracts using
[P256](https://docs.openzeppelin.com/contracts/5.x/api/utils#P256)
as an alternative to traditional secp256k1 ECDSA signatures. This library verifies
signatures generated during WebAuthn authentication ceremonies as specified in the
[WebAuthn Level 2 standard](https://www.w3.org/TR/webauthn-2/).

For blockchain use cases, the following WebAuthn validations are intentionally omitted:

* Origin validation: Origin verification in `clientDataJSON` is omitted as blockchain
  contexts rely on authenticator and dapp frontend enforcement. Standard authenticators
  implement proper origin validation.
* RP ID hash validation: Verification of `rpIdHash` in authenticatorData against expected
  RP ID hash is omitted. This is typically handled by platform-level security measures.
  Including an expiry timestamp in signed data is recommended for enhanced security.
* Signature counter: Verification of signature counter increments is omitted. While
  useful for detecting credential cloning, on-chain operations typically include nonce
  protection, making this check redundant.
* Extension outputs: Extension output value verification is omitted as these are not
  essential for core authentication security in blockchain applications.
* Attestation: Attestation object verification is omitted as this implementation
  focuses on authentication (`webauthn.get`) rather than registration ceremonies.

Inspired by:

* [daimo-eth implementation](https://github.com/daimo-eth/p256-verifier/blob/master/src/WebAuthn.sol)
* [base implementation](https://github.com/base/webauthn-sol/blob/main/src/WebAuthn.sol)

<div className="bg-secondary p-4 rounded-md mb-6">
<h3 style={{ marginTop: "0"}}>Functions</h3>
<div className="font-mono">
- [verify(challenge, auth, qx, qy)](#WebAuthn-verify-bytes-struct-WebAuthn-WebAuthnAuth-bytes32-bytes32-)
- [verify(challenge, auth, qx, qy, requireUV)](#WebAuthn-verify-bytes-struct-WebAuthn-WebAuthnAuth-bytes32-bytes32-bool-)
- [tryDecodeAuth(input)](#WebAuthn-tryDecodeAuth-bytes-)
</div>
</div>

<a id="WebAuthn-verify-bytes-struct-WebAuthn-WebAuthnAuth-bytes32-bytes32-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">verify(bytes challenge, struct WebAuthn.WebAuthnAuth auth, bytes32 qx, bytes32 qy) → bool</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="WebAuthn-verify-bytes-struct-WebAuthn-WebAuthnAuth-bytes32-bytes32-">#</a>
</div>
</div>
<div className="px-4">

Performs standard verification of a WebAuthn Authentication Assertion.

</div>
</div>

<a id="WebAuthn-verify-bytes-struct-WebAuthn-WebAuthnAuth-bytes32-bytes32-bool-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">verify(bytes challenge, struct WebAuthn.WebAuthnAuth auth, bytes32 qx, bytes32 qy, bool requireUV) → bool</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="WebAuthn-verify-bytes-struct-WebAuthn-WebAuthnAuth-bytes32-bytes32-bool-">#</a>
</div>
</div>
<div className="px-4">

Performs verification of a WebAuthn Authentication Assertion. This variants allow the caller to select
whether of not to require the UV flag (step 17).

Verifies:

1. Type is "webauthn.get" (see [`WebAuthn._validateExpectedTypeHash`](#WebAuthn-_validateExpectedTypeHash-string-uint256-))
2. Challenge matches the expected value (see [`WebAuthn._validateChallenge`](#WebAuthn-_validateChallenge-string-uint256-bytes-))
3. Cryptographic signature is valid for the given public key
4. confirming physical user presence during authentication
5. (if `requireUV` is true) confirming stronger user authentication (biometrics/PIN)
6. Backup Eligibility (`BE`) and Backup State (BS) bits relationship is valid

</div>
</div>

<a id="WebAuthn-tryDecodeAuth-bytes-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">tryDecodeAuth(bytes input) → bool success, struct WebAuthn.WebAuthnAuth auth</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="WebAuthn-tryDecodeAuth-bytes-">#</a>
</div>
</div>
<div className="px-4">

Verifies that calldata bytes (`input`) represents a valid `WebAuthnAuth` object. If encoding is valid,
returns true and the calldata view at the object. Otherwise, returns false and an invalid calldata object.

<Callout>
The returned `auth` object should not be accessed if `success` is false. Trying to access the data may
cause revert/panic.
</Callout>

</div>
</div>

<a id="ZKEmailUtils"></a>

<div style={{marginTop: "4em"}} className="w-full flex flex-row items-center justify-between">

## `ZKEmailUtils`

<a target="_blank" style={{marginTop: "1.5em"}} href="https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/ZKEmailUtils.sol">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github-icon lucide-github"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
</a>

</div>

```solidity
import "@openzeppelin/community-contracts/utils/cryptography/ZKEmailUtils.sol";
```

Library for [ZKEmail](https://docs.zk.email) Groth16 proof validation utilities.

ZKEmail is a protocol that enables email-based authentication and authorization for smart contracts
using zero-knowledge proofs. It allows users to prove ownership of an email address without revealing
the email content or private keys.

The validation process involves several key components:

* A [DKIMRegistry](https://docs.zk.email/architecture/dkim-verification) (DomainKeys Identified Mail) verification
mechanism to ensure the email was sent from a valid domain. Defined by an `IDKIMRegistry` interface.
* A [command template](https://docs.zk.email/email-tx-builder/architecture/command-templates) validation
mechanism to ensure the email command matches the expected format and parameters.
* A [zero-knowledge proof](https://docs.zk.email/architecture/zk-proofs#how-zk-email-uses-zero-knowledge-proofs) verification
mechanism to ensure the email was actually sent and received without revealing its contents. Defined by an `IGroth16Verifier` interface.

<div className="bg-secondary p-4 rounded-md mb-6">
<h3 style={{ marginTop: "0"}}>Functions</h3>
<div className="font-mono">
- [isValidZKEmail(emailProof, dkimregistry, groth16Verifier, hash)](#ZKEmailUtils-isValidZKEmail-struct-EmailProof-contract-IDKIMRegistry-contract-IGroth16Verifier-bytes32-)
- [isValidZKEmail(emailProof, dkimregistry, groth16Verifier, template, templateParams)](#ZKEmailUtils-isValidZKEmail-struct-EmailProof-contract-IDKIMRegistry-contract-IGroth16Verifier-string---bytes---)
- [isValidZKEmail(emailProof, dkimregistry, groth16Verifier, template, templateParams, stringCase)](#ZKEmailUtils-isValidZKEmail-struct-EmailProof-contract-IDKIMRegistry-contract-IGroth16Verifier-string---bytes---enum-ZKEmailUtils-Case-)
- [tryDecodeEmailProof(input)](#ZKEmailUtils-tryDecodeEmailProof-bytes-)
- [toPubSignals(proof)](#ZKEmailUtils-toPubSignals-struct-EmailProof-)
</div>
</div>

<a id="ZKEmailUtils-isValidZKEmail-struct-EmailProof-contract-IDKIMRegistry-contract-IGroth16Verifier-bytes32-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">isValidZKEmail(struct EmailProof emailProof, contract IDKIMRegistry dkimregistry, contract IGroth16Verifier groth16Verifier, bytes32 hash) → enum ZKEmailUtils.EmailProofError</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="ZKEmailUtils-isValidZKEmail-struct-EmailProof-contract-IDKIMRegistry-contract-IGroth16Verifier-bytes32-">#</a>
</div>
</div>
<div className="px-4">

Variant of [`ZKEmailUtils.isValidZKEmail`](#ZKEmailUtils-isValidZKEmail-struct-EmailProof-contract-IDKIMRegistry-contract-IGroth16Verifier-string---bytes---enum-ZKEmailUtils-Case-) that validates the `["signHash", "../access#AccessManagerLight-ADMIN_ROLE-uint8"]` command template.

</div>
</div>

<a id="ZKEmailUtils-isValidZKEmail-struct-EmailProof-contract-IDKIMRegistry-contract-IGroth16Verifier-string---bytes---"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">isValidZKEmail(struct EmailProof emailProof, contract IDKIMRegistry dkimregistry, contract IGroth16Verifier groth16Verifier, string[] template, bytes[] templateParams) → enum ZKEmailUtils.EmailProofError</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="ZKEmailUtils-isValidZKEmail-struct-EmailProof-contract-IDKIMRegistry-contract-IGroth16Verifier-string---bytes---">#</a>
</div>
</div>
<div className="px-4">

Validates a ZKEmail proof against a command template.

This function takes an email proof, a DKIM registry contract, and a verifier contract
as inputs. It performs several validation checks and returns an [`ZKEmailUtils.EmailProofError`](#ZKEmailUtils-EmailProofError) indicating the result.
Returns `EmailProofError.NoError` if all validations pass, or a specific [`ZKEmailUtils.EmailProofError`](#ZKEmailUtils-EmailProofError) indicating
which validation check failed.

<Callout>
Attempts to validate the command for all possible string [`ZKEmailUtils.Case`](#ZKEmailUtils-Case) values.
</Callout>

</div>
</div>

<a id="ZKEmailUtils-isValidZKEmail-struct-EmailProof-contract-IDKIMRegistry-contract-IGroth16Verifier-string---bytes---enum-ZKEmailUtils-Case-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">isValidZKEmail(struct EmailProof emailProof, contract IDKIMRegistry dkimregistry, contract IGroth16Verifier groth16Verifier, string[] template, bytes[] templateParams, enum ZKEmailUtils.Case stringCase) → enum ZKEmailUtils.EmailProofError</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="ZKEmailUtils-isValidZKEmail-struct-EmailProof-contract-IDKIMRegistry-contract-IGroth16Verifier-string---bytes---enum-ZKEmailUtils-Case-">#</a>
</div>
</div>
<div className="px-4">

Variant of [`ZKEmailUtils.isValidZKEmail`](#ZKEmailUtils-isValidZKEmail-struct-EmailProof-contract-IDKIMRegistry-contract-IGroth16Verifier-string---bytes---enum-ZKEmailUtils-Case-) that validates a template with a specific string [`ZKEmailUtils.Case`](#ZKEmailUtils-Case).

Useful for templates with Ethereum address matchers (i.e. ``ethAddr``), which are case-sensitive (e.g., `["someCommand", "../access#AccessManagerLight-_groups-mapping-address----Masks-Mask-"]`).

</div>
</div>

<a id="ZKEmailUtils-tryDecodeEmailProof-bytes-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">tryDecodeEmailProof(bytes input) → bool success, struct EmailProof emailProof</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="ZKEmailUtils-tryDecodeEmailProof-bytes-">#</a>
</div>
</div>
<div className="px-4">

Verifies that calldata bytes (`input`) represents a valid `EmailProof` object. If encoding is valid,
returns true and the calldata view at the object. Otherwise, returns false and an invalid calldata object.

<Callout>
The returned `emailProof` object should not be accessed if `success` is false. Trying to access the data may
cause revert/panic.
</Callout>

</div>
</div>

<a id="ZKEmailUtils-toPubSignals-struct-EmailProof-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">toPubSignals(struct EmailProof proof) → uint256[34] pubSignals</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="ZKEmailUtils-toPubSignals-struct-EmailProof-">#</a>
</div>
</div>
<div className="px-4">

Builds the expected public signals array for the Groth16 verifier from the given EmailProof.

Packs the domain, public key hash, email nullifier, timestamp, masked command, account salt, and isCodeExist fields
into a uint256 array in the order expected by the verifier circuit.

</div>
</div>

<a id="SignerWebAuthn"></a>

<div style={{marginTop: "4em"}} className="w-full flex flex-row items-center justify-between">

## `SignerWebAuthn`

<a target="_blank" style={{marginTop: "1.5em"}} href="https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/signers/SignerWebAuthn.sol">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github-icon lucide-github"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
</a>

</div>

```solidity
import "@openzeppelin/community-contracts/utils/cryptography/signers/SignerWebAuthn.sol";
```

Implementation of `SignerP256` that supports WebAuthn authentication assertions.

This contract enables signature validation using WebAuthn authentication assertions,
leveraging the P256 public key stored in the contract. It allows for both WebAuthn
and raw P256 signature validation, providing compatibility with both signature types.

The signature is expected to be an abi-encoded [`WebAuthn.WebAuthnAuth`](#WebAuthn-WebAuthnAuth) struct.

Example usage:

```solidity
contract MyAccountWebAuthn is Account, SignerWebAuthn, Initializable {
    function initialize(bytes32 qx, bytes32 qy) public initializer {
        _setSigner(qx, qy);
    }
}
```

<Callout type="warn">
Failing to call [`ERC7579Signature._setSigner`](../account#ERC7579Signature-_setSigner-address-bytes-) either during construction (if used standalone)
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.
</Callout>

<div className="bg-secondary p-4 rounded-md mb-6">
<h3 style={{ marginTop: "0"}}>Functions</h3>
<div className="font-mono">
- [_rawSignatureValidation(hash, signature)](#SignerWebAuthn-_rawSignatureValidation-bytes32-bytes-)
#### SignerP256 [!toc]
- [_setSigner(qx, qy)](#SignerP256-_setSigner-bytes32-bytes32-)
- [signer()](#SignerP256-signer--)
#### AbstractSigner [!toc]
</div>
</div>

<div className="bg-secondary p-4 rounded-md mb-6">
<h3 style={{ marginTop: "0"}}>Errors</h3>
<div className="font-mono">
#### SignerP256 [!toc]
- [SignerP256InvalidPublicKey(qx, qy)](#SignerP256-SignerP256InvalidPublicKey-bytes32-bytes32-)
#### AbstractSigner [!toc]
</div>
</div>

<a id="SignerWebAuthn-_rawSignatureValidation-bytes32-bytes-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">_rawSignatureValidation(bytes32 hash, bytes signature) → bool</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="SignerWebAuthn-_rawSignatureValidation-bytes32-bytes-">#</a>
</div>
</div>
<div className="px-4">

Validates a raw signature using the WebAuthn authentication assertion.

In case the signature can't be validated, it falls back to the
`SignerP256-_rawSignatureValidation` method for raw P256 signature validation by passing
the raw `r` and `s` values from the signature.

</div>
</div>

<a id="SignerZKEmail"></a>

<div style={{marginTop: "4em"}} className="w-full flex flex-row items-center justify-between">

## `SignerZKEmail`

<a target="_blank" style={{marginTop: "1.5em"}} href="https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/signers/SignerZKEmail.sol">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github-icon lucide-github"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
</a>

</div>

```solidity
import "@openzeppelin/community-contracts/utils/cryptography/signers/SignerZKEmail.sol";
```

Implementation of `AbstractSigner` using [ZKEmail](https://docs.zk.email) signatures.

ZKEmail enables secure authentication and authorization through email messages, leveraging
DKIM signatures from a [`DKIMRegistry`](#DKIMRegistry) and zero-knowledge proofs enabled by a [`SignerZKEmail.verifier`](#SignerZKEmail-verifier--)
contract that ensures email authenticity without revealing sensitive information. The DKIM
registry is trusted to correctly update DKIM keys, but users can override this behaviour and
set their own keys. This contract implements the core functionality for validating email-based
signatures in smart contracts.

Developers must set the following components during contract initialization:

* [`SignerZKEmail.accountSalt`](#SignerZKEmail-accountSalt--) - A unique identifier derived from the user's email address and account code.
* [`DKIMRegistry`](#DKIMRegistry) - An instance of the DKIM registry contract for domain verification.
* [`SignerZKEmail.verifier`](#SignerZKEmail-verifier--) - An instance of the Groth16Verifier contract for zero-knowledge proof validation.

Example of usage:

```solidity
contract MyAccountZKEmail is Account, SignerZKEmail, Initializable {
  function initialize(
      bytes32 accountSalt,
      IDKIMRegistry registry,
      IGroth16Verifier groth16Verifier
  ) public initializer {
      // Will revert if the signer is already initialized
      _setAccountSalt(accountSalt);
      _setDKIMRegistry(registry);
      _setVerifier(groth16Verifier);
  }
}
```

<Callout type="warn">
Failing to call [`SignerZKEmail._setAccountSalt`](#SignerZKEmail-_setAccountSalt-bytes32-), [`SignerZKEmail._setDKIMRegistry`](#SignerZKEmail-_setDKIMRegistry-contract-IDKIMRegistry-), and [`SignerZKEmail._setVerifier`](#SignerZKEmail-_setVerifier-contract-IGroth16Verifier-)
either during construction (if used standalone) or during initialization (if used as a clone) may
leave the signer either front-runnable or unusable.
</Callout>

<div className="bg-secondary p-4 rounded-md mb-6">
<h3 style={{ marginTop: "0"}}>Functions</h3>
<div className="font-mono">
- [accountSalt()](#SignerZKEmail-accountSalt--)
- [DKIMRegistry()](#SignerZKEmail-DKIMRegistry--)
- [verifier()](#SignerZKEmail-verifier--)
- [_setAccountSalt(accountSalt_)](#SignerZKEmail-_setAccountSalt-bytes32-)
- [_setDKIMRegistry(registry_)](#SignerZKEmail-_setDKIMRegistry-contract-IDKIMRegistry-)
- [_setVerifier(verifier_)](#SignerZKEmail-_setVerifier-contract-IGroth16Verifier-)
- [_rawSignatureValidation(hash, signature)](#SignerZKEmail-_rawSignatureValidation-bytes32-bytes-)
#### AbstractSigner [!toc]
</div>
</div>

<div className="bg-secondary p-4 rounded-md mb-6">
<h3 style={{ marginTop: "0"}}>Errors</h3>
<div className="font-mono">
- [InvalidEmailProof(err)](#SignerZKEmail-InvalidEmailProof-enum-ZKEmailUtils-EmailProofError-)
#### AbstractSigner [!toc]
</div>
</div>

<a id="SignerZKEmail-accountSalt--"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">accountSalt() → bytes32</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">public</p>
<a className="peer" data-card href="SignerZKEmail-accountSalt--">#</a>
</div>
</div>
<div className="px-4">

Unique identifier for owner of this contract defined as a hash of an email address and an account code.

An account code is a random integer in a finite scalar field of [BN254](https://neuromancer.sk/std/bn/bn254) curve.
It is a private randomness to derive a CREATE2 salt of the user's Ethereum address
from the email address, i.e., userEtherAddr := CREATE2(hash(userEmailAddr, accountCode)).

The account salt is used for:

* Privacy: Enables email address privacy on-chain so long as the randomly generated account code is not revealed
  to an adversary.
* Security: Provides a unique identifier that cannot be easily guessed or brute-forced, as it's derived
  from both the email address and a random account code.
* Deterministic Address Generation: Enables the creation of deterministic addresses based on email addresses,
  allowing users to recover their accounts using only their email.

</div>
</div>

<a id="SignerZKEmail-DKIMRegistry--"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">DKIMRegistry() → contract IDKIMRegistry</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">public</p>
<a className="peer" data-card href="SignerZKEmail-DKIMRegistry--">#</a>
</div>
</div>
<div className="px-4">

An instance of the DKIM registry contract.
See [DKIM Verification](https://docs.zk.email/architecture/dkim-verification).

</div>
</div>

<a id="SignerZKEmail-verifier--"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">verifier() → contract IGroth16Verifier</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">public</p>
<a className="peer" data-card href="SignerZKEmail-verifier--">#</a>
</div>
</div>
<div className="px-4">

An instance of the Groth16Verifier contract.
See [ZK Proofs](https://docs.zk.email/architecture/zk-proofs#how-zk-email-uses-zero-knowledge-proofs).

</div>
</div>

<a id="SignerZKEmail-_setAccountSalt-bytes32-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">_setAccountSalt(bytes32 accountSalt_)</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="SignerZKEmail-_setAccountSalt-bytes32-">#</a>
</div>
</div>
<div className="px-4">

Set the [`SignerZKEmail.accountSalt`](#SignerZKEmail-accountSalt--).

</div>
</div>

<a id="SignerZKEmail-_setDKIMRegistry-contract-IDKIMRegistry-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">_setDKIMRegistry(contract IDKIMRegistry registry_)</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="SignerZKEmail-_setDKIMRegistry-contract-IDKIMRegistry-">#</a>
</div>
</div>
<div className="px-4">

Set the [`DKIMRegistry`](#DKIMRegistry) contract address.

</div>
</div>

<a id="SignerZKEmail-_setVerifier-contract-IGroth16Verifier-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">_setVerifier(contract IGroth16Verifier verifier_)</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="SignerZKEmail-_setVerifier-contract-IGroth16Verifier-">#</a>
</div>
</div>
<div className="px-4">

Set the [`SignerZKEmail.verifier`](#SignerZKEmail-verifier--) contract address.

</div>
</div>

<a id="SignerZKEmail-_rawSignatureValidation-bytes32-bytes-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">_rawSignatureValidation(bytes32 hash, bytes signature) → bool</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="SignerZKEmail-_rawSignatureValidation-bytes32-bytes-">#</a>
</div>
</div>
<div className="px-4">

See `AbstractSigner-_rawSignatureValidation`. Validates a raw signature by:

1. Decoding the email proof from the signature
2. Validating the account salt matches
3. Verifying the email proof using ZKEmail utilities

</div>
</div>

<a id="SignerZKEmail-InvalidEmailProof-enum-ZKEmailUtils-EmailProofError-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">InvalidEmailProof(enum ZKEmailUtils.EmailProofError err)</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">error</p>
<a className="peer" data-card href="SignerZKEmail-InvalidEmailProof-enum-ZKEmailUtils-EmailProofError-">#</a>
</div>
</div>
<div className="px-4">

Proof verification error.

</div>
</div>

<a id="ERC7913WebAuthnVerifier"></a>

<div style={{marginTop: "4em"}} className="w-full flex flex-row items-center justify-between">

## `ERC7913WebAuthnVerifier`

<a target="_blank" style={{marginTop: "1.5em"}} href="https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/verifiers/ERC7913WebAuthnVerifier.sol">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github-icon lucide-github"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
</a>

</div>

```solidity
import "@openzeppelin/community-contracts/utils/cryptography/verifiers/ERC7913WebAuthnVerifier.sol";
```

ERC-7913 signature verifier that supports WebAuthn authentication assertions.

This verifier enables the validation of WebAuthn signatures using P256 public keys.
The key is expected to be a 64-byte concatenation of the P256 public key coordinates (qx || qy).
The signature is expected to be an abi-encoded [`WebAuthn.WebAuthnAuth`](#WebAuthn-WebAuthnAuth) struct.

Uses `WebAuthn-verifyMinimal` for signature verification, which performs the essential
WebAuthn checks: type validation, challenge matching, and cryptographic signature verification.

<Callout>
Wallets that may require default P256 validation may install a P256 verifier separately.
</Callout>

<div className="bg-secondary p-4 rounded-md mb-6">
<h3 style={{ marginTop: "0"}}>Functions</h3>
<div className="font-mono">
- [verify(key, hash, signature)](#ERC7913WebAuthnVerifier-verify-bytes-bytes32-bytes-)
#### IERC7913SignatureVerifier [!toc]
</div>
</div>

<a id="ERC7913WebAuthnVerifier-verify-bytes-bytes32-bytes-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">verify(bytes key, bytes32 hash, bytes signature) → bytes4</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">public</p>
<a className="peer" data-card href="ERC7913WebAuthnVerifier-verify-bytes-bytes32-bytes-">#</a>
</div>
</div>
<div className="px-4">

Verifies `signature` as a valid signature of `hash` by `key`.

MUST return the bytes4 magic value IERC7913SignatureVerifier.verify.selector if the signature is valid.
SHOULD return 0xffffffff or revert if the signature is not valid.
SHOULD return 0xffffffff or revert if the key is empty

</div>
</div>

<a id="ERC7913ZKEmailVerifier"></a>

<div style={{marginTop: "4em"}} className="w-full flex flex-row items-center justify-between">

## `ERC7913ZKEmailVerifier`

<a target="_blank" style={{marginTop: "1.5em"}} href="https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/verifiers/ERC7913ZKEmailVerifier.sol">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github-icon lucide-github"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
</a>

</div>

```solidity
import "@openzeppelin/community-contracts/utils/cryptography/verifiers/ERC7913ZKEmailVerifier.sol";
```

ERC-7913 signature verifier that supports ZKEmail accounts.

This contract verifies signatures produced through ZKEmail's zero-knowledge
proofs which allows users to authenticate using their email addresses.

The key decoding logic is customizable: users may override the [`ERC7913ZKEmailVerifier._decodeKey`](#ERC7913ZKEmailVerifier-_decodeKey-bytes-) function
to enforce restrictions or validation on the decoded values (e.g., requiring a specific
verifier or registry). To remain compliant with ERC-7913's statelessness,
it is recommended to enforce such restrictions using immutable variables only.

Example of overriding _decodeKey to enforce a specific verifier, registry:

```solidity
  function _decodeKey(bytes calldata key) internal view override returns (
      IDKIMRegistry registry,
      bytes32 accountSalt,
      IGroth16Verifier verifier
  ) {
      (registry, accountSalt, verifier) = super._decodeKey(key);
      require(verifier == _verifier, "Invalid verifier");
      require(registry == _registry, "Invalid registry");
      return (registry, accountSalt, verifier);
  }
```

<div className="bg-secondary p-4 rounded-md mb-6">
<h3 style={{ marginTop: "0"}}>Functions</h3>
<div className="font-mono">
- [verify(key, hash, signature)](#ERC7913ZKEmailVerifier-verify-bytes-bytes32-bytes-)
- [_decodeKey(key)](#ERC7913ZKEmailVerifier-_decodeKey-bytes-)
#### IERC7913SignatureVerifier [!toc]
</div>
</div>

<a id="ERC7913ZKEmailVerifier-verify-bytes-bytes32-bytes-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">verify(bytes key, bytes32 hash, bytes signature) → bytes4</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">public</p>
<a className="peer" data-card href="ERC7913ZKEmailVerifier-verify-bytes-bytes32-bytes-">#</a>
</div>
</div>
<div className="px-4">

Verifies a zero-knowledge proof of an email signature validated by a [`DKIMRegistry`](#DKIMRegistry) contract.

The key format is ABI-encoded (IDKIMRegistry, bytes32, IGroth16Verifier) where:

* IDKIMRegistry: The registry contract that validates DKIM public key hashes
* bytes32: The account salt that uniquely identifies the user's email address
* IGroth16Verifier: The verifier contract instance for ZK proof verification.

See [`ERC7913ZKEmailVerifier._decodeKey`](#ERC7913ZKEmailVerifier-_decodeKey-bytes-) for the key encoding format.

The signature is an ABI-encoded [`ZKEmailUtils.EmailProofError`](#ZKEmailUtils-EmailProofError) struct containing
the proof details.

Signature encoding:

```solidity
bytes memory signature = abi.encode(EmailProof({
    domainName: "example.com", // The domain name of the email sender
    publicKeyHash: bytes32(0x...), // Hash of the DKIM public key used to sign the email
    timestamp: block.timestamp, // When the email was sent
    maskedCommand: "signHash 12345...", // The command being executed, with sensitive data masked
    emailNullifier: bytes32(0x...), // Unique identifier for the email to prevent replay attacks
    accountSalt: bytes32(0x...), // Unique identifier derived from email and account code
    isCodeExist: true, // Whether the account code exists in the proof
    proof: bytes(0x...) // The zero-knowledge proof verifying the email's authenticity
}));
```

</div>
</div>

<a id="ERC7913ZKEmailVerifier-_decodeKey-bytes-"></a>

<div className="border rounded-md mb-4">
<div className="bg-secondary flex w-full justify-between px-4">
<p className="font-bold text-sm font-mono">_decodeKey(bytes key) → contract IDKIMRegistry registry, bytes32 accountSalt, contract IGroth16Verifier verifier</p>
<div className="flex flex-row items-center gap-2">
<p className="font-light text-sm">internal</p>
<a className="peer" data-card href="ERC7913ZKEmailVerifier-_decodeKey-bytes-">#</a>
</div>
</div>
<div className="px-4">

Decodes the key into its components.

```solidity
bytes memory key = abi.encode(registry, accountSalt, verifier);
```

</div>
</div>
