---
title: ERC-6909
---

ERC-6909 is a draft EIP that draws on ERC-1155 learnings since it was published in 2018. The main goals of ERC-6909 is to decrease gas costs and complexity--this is mainly accomplished by removing batching and callbacks.

<Callout>
To understand the inspiration for a multi token standard, see the [multi token standard](./erc1155#multi-token-standard) section within the EIP-1155 docs.
</Callout>

## Changes from ERC-1155

There are three main changes from ERC-1155 which are as follows:

1. The removal of batch operations.
2. The removal of transfer callbacks.
3. Granularization in approvals--approvals can be set globally (as operators) or as amounts per token (inspired by ERC20).

## Constructing an ERC-6909 Token Contract

We’ll use ERC-6909 to track multiple items in a game, each having their own unique attributes. All item types will by minted to the deployer of the contract, which we can later transfer to players. We’ll also use the [`ERC6909Metadata`](/contracts/5.x/api/token/ERC6909#ERC6909Metadata) extension to add decimals to our fungible items (the vanilla ERC-6909 implementation does not have decimals).

For simplicity, we will mint all items in the constructor--however, minting functionality could be added to the contract to mint on demand to players.

<Callout>
For an overview of minting mechanisms, check out [Creating ERC-20 Supply](./erc20-supply).
</Callout>

Here’s what a contract for tokenized items might look like:

<include cwd lang='solidity'>./examples/token/ERC6909/ERC6909GameItems.sol</include>

Note that there is no content URI functionality in the base implementation, but the [`ERC6909ContentURI`](/contracts/5.x/api/token/ERC6909#ERC6909ContentURI) extension adds it. Additionally, the base implementation does not track total supplies, but the [`ERC6909TokenSupply`](/contracts/5.x/api/token/ERC6909#ERC6909TokenSupply) extension tracks the total supply of each token id.

Once the contract is deployed, we will be able to query the deployer’s balance:
```javascript
> gameItems.balanceOf(deployerAddress, 3)
1000000000
```

We can transfer items to player accounts:
```javascript
> gameItems.transfer(playerAddress, 2, 1)
> gameItems.balanceOf(playerAddress, 2)
1
> gameItems.balanceOf(deployerAddress, 2)
0
```
